diff -ruN dgd/Changelog.NET dgd-net/Changelog.NET
--- dgd/Changelog.NET	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/Changelog.NET	2009-03-03 01:09:11.000000000 +0100
@@ -0,0 +1,26 @@
+1.2.144-NET-01
+
+- Updated to DGD 1.2.144
+
+1.2.144-NET-02
+
+- Properly decrease the number of pending connects when a connection fails
+- Prevent pending connections from hogging the CPU
+
+1.2.144-NET-03
+
+- New config file statement: 'ports = num;' to set the number of ports that
+  can be used.
+- Deal with running out of users properly for incoming connections.
+
+1.2.157-NET-04
+
+- Fixed two cases of port numbers using network byte order instead of host
+  byte order. This concerns inbound tcp connections and udp datagrams
+- Fixed a segment violation in send_datagram() 
+- Changed udp datagram queueing, it needs to be implemented in lpc
+
+1.2.157-NET-05
+
+- Fixed a crash when using query_ip_number() or query_ip_name() on a port
+  object.
diff -ruN dgd/Copyright.NET dgd-net/Copyright.NET
--- dgd/Copyright.NET	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/Copyright.NET	2008-05-19 21:21:47.000000000 +0200
@@ -0,0 +1,19 @@
+The networking-DGD package is Copyright 1994-1996 by Richard Braakman,
+Copyright 1996-1999 by Erwin Harte, Copyright 2000 by Neil McBride, 
+Copyright 2003 by Michael Bergbauer, and Copyright 2007 by Bart van
+Leeuwen.
+
+The package is also a derived work of Dworkin's Generic Driver, which
+is copyrighted by BeeHive Internet Technologies, Inc.  Therefore, its
+copyright applies to it in addition to mine.  Its license is included
+in the file Copyright.DGD.
+
+I grant permission for any use of this package which does not conflict
+with the terms of the DGD copyright mentioned above.
+
+Richard Braakman <dark@xs4all.nl>
+Erwin Harte <dgd-net@harte.is-here.com>
+Neil McBride <sarak@castinian.org>
+Michael Bergbauer <dgd-network@noname.franken.de>
+Bart van Leeuwen <bart@wotf.org>
+
diff -ruN dgd/doc/connect dgd-net/doc/connect
--- dgd/doc/connect	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/doc/connect	2009-02-13 23:59:26.000000000 +0100
@@ -0,0 +1,29 @@
+NAME
+        connect - initiate a tcp connection
+
+SYNOPSIS
+        void connect(string ipnumber, int port, varargs string protocol)
+
+
+DESCRIPTION
+        Initiate a telnet or tcp connection to the specified host and port,
+        and associate the connection with this object when it is established.
+        The protocol may be "telnet" or "tcp", or it may be omitted to
+        default to "tcp".
+
+        When the connection succeeds, open() will be called in obj.  If it
+        fails or times out, close() will be called in obj.  After the
+        connection is established, obj will be a normal user object.
+
+ERRORS                                                                         
+        An error will result if the object was already has a connection,
+        port, or editor associated with it.
+        If the number of existing port and connection objects is equal
+        to the value of status()[ST_UTABSIZE], calling connect() results
+        in an error.
+
+
+SEE ALSO
+        kfun/open_port, kfun/send_message, kfun/send_datagram, 
+	kfun/close_user
+
diff -ruN dgd/doc/kfun/datagram_challenge dgd-net/doc/kfun/datagram_challenge
--- dgd/doc/kfun/datagram_challenge	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/doc/kfun/datagram_challenge	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
-NAME
-	datagram_challenge - set the datagram challenge
-
-SYNOPSIS
-	void datagram_challenge(string challenge)
-
-
-DESCRIPTION
-	Set the datagram challenge for the current binary user object.  The
-	client must send this challenge in order to open the datagram channel,
-	after which open_datagram() will be called in the object.  All
-	outstanding challenges must be unique.
-
-ERRORS
-	An error will result if a challenge has already been set for the
-	current object.
-
-SEE ALSO
-	kfun/query_ip_name, kfun/query_ip_number, kfun/send_datagram,
-	kfun/this_user, kfun/users
diff -ruN dgd/doc/kfun/open_port dgd-net/doc/kfun/open_port
--- dgd/doc/kfun/open_port	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/doc/kfun/open_port	2009-02-13 23:59:26.000000000 +0100
@@ -0,0 +1,50 @@
+NAME
+	open_port - associate an object with an tcp/udp port
+
+SYNOPSIS
+	int open_port(string protocol, varargs int port)
+
+DESCRIPTION
+	Open a port on the host machine and connect it to this object, which
+        is then known as a "port object".  The protocol may be any of "tcp",
+        "udp", or "telnet".  Port objects behave differently, depending on
+        the protocol. If the port number is omitted (meaning that the kfun
+        is called with only _one_ argument) a random unused port will be
+        selected.
+
+	When a port is first opened, open(int port) is called in its port
+        object.  When it is closed for any reason, close(int force) is 
+	called in its port object, force indicaton whether we closed the
+	connection with close_user (set to 1) or if something else
+	closed the connection (set to 0).
+
+	Destructing a port object will close its port first.                 
+
+	In a telnet or tcp port,
+             connection(string ipnumber, int port)
+        will be called whenever a client connects to it.  This function
+        should return an object that will then be known as a "user object"
+
+	In an udp port,        
+            receive_datagram(string data, string ipnumber, int port)
+        will be called whenever a datagram arrives on its port.  The
+        ipnumber and port will be those of the sender.  UDP port objects
+        may also send datagrams.
+
+ERRORS                         
+        An error will result if the object was already has a connection,
+        port, or editor associated with it.
+        If the number of existing port and connection objects is equal
+        to the value of status()[ST_UTABSIZE], calling open_port() results
+        in an error.                                                           
+        If it is immediately apparent that the port cannot be opened,
+        an error will be reported.  In such a case, neither open() nor
+        close() will be called in the port object.
+
+SEE ALSO
+        kfun/ports, kfun/send_datagram, kfun/send_message, kfun/connect
+	kfun/close_user
+
+
+
+
diff -ruN dgd/doc/kfun/ports dgd-net/doc/kfun/ports
--- dgd/doc/kfun/ports	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/doc/kfun/ports	2009-02-13 23:59:26.000000000 +0100
@@ -0,0 +1,14 @@
+NAME
+        ports - return the array of port objects
+
+SYNOPSIS
+        object *ports()
+
+
+DESCRIPTION
+        Return an array containing the objects associated with the
+        currently open ports.
+
+SEE ALSO
+        kfun/open_port, kfun/users
+
diff -ruN dgd/doc/kfun/send_datagram dgd-net/doc/kfun/send_datagram
--- dgd/doc/kfun/send_datagram	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/doc/kfun/send_datagram	2009-02-13 23:59:26.000000000 +0100
@@ -2,20 +2,18 @@
 	send_datagram - send a message on the datagram channel
 
 SYNOPSIS
-	int send_datagram(string message)
+	int send_datagram(string message, string ip, int port)
 
 
 DESCRIPTION
-	Send a message on the datagram channel of a binary user object.  At
-	least one message must have been received on the same channel before
-	this function can be used.  The return value is the length of the
-	message if it could be sent, or 0 otherwise.
-	No more than one datagram can be sent per user object during each
-	thread.
+	Send a message on the datagram channel of an udp port object.  
+        Before a datagram can be sent or received, the object must open
+        an udp port. This port can be used for sending and receiving udp
+        packets to and from multiple hosts at the same time.
 
 ERRORS
-	An error will result if the current object has no datagram channel.
+	An error will result if the current object has no open udp port
 
 SEE ALSO
-	kfun/datagram_challenge, kfun/query_ip_name, kfun/query_ip_number,
-	kfun/send_message, kfun/this_user, kfun/users
+	kfun/open_port, kfun/query_ip_name, kfun/query_ip_number,
+	kfun/ports
diff -ruN dgd/doc/kfun/send_message dgd-net/doc/kfun/send_message
--- dgd/doc/kfun/send_message	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/doc/kfun/send_message	2009-02-13 23:59:26.000000000 +0100
@@ -8,17 +8,19 @@
 
 DESCRIPTION
 	In the first form, send a message to the user associated with the
-	current object, returning the number of bytes that could be sent.
-	When used by the driver object, the string will be written to stderr.
-	In the second form, user input echoing will be turned off or on,
-	depending on the value of the argument being zero or non-zero,
-	respectively; the return value is 1 if input echoing could be set, or 0
-	otherwise.
-	When the output buffer has emptied, message_done() will be called in
-	the user object.  If send_message() is called again before the output
-	buffer has fully drained, message_done() will not be called before the
-	output buffer has emptied completely.
+	current object.  In the second form, user input echoing will be
+	turned off or on, the value of echo being zero or non-zero,
+	respectively.  Used by the driver object, send_message() will write
+	the message on stderr.
+	For binary connections, send_message() will return the length of the
+	string if it could be sent right away, a number indicating how much of
+	the string could be sent immediately, or -1 otherwise.  If only part of
+	the string could be sent initially, message_done() will be called in
+	the user object when the remainder has also been sent.  If
+	send_message() is used to send new data before all of the pending data
+	from a previous call has been sent, the pending data is discarded.
+	For telnet connections, send_message() will always return the length
+	of the string sent.
 
 SEE ALSO
-	kfun/datagram_challenge, kfun/query_ip_name, kfun/query_ip_number,
-	kfun/send_datagram, kfun/this_user, kfun/users
+	kfun/query_ip_number, kfun/this_user, kfun/users
diff -ruN dgd/doc/net/README dgd-net/doc/net/README
--- dgd/doc/net/README	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/doc/net/README	2009-02-13 23:59:26.000000000 +0100
@@ -0,0 +1 @@
+udpqueue.c         : example of udp queue for use with the network package
diff -ruN dgd/doc/net/udpqueue.c dgd-net/doc/net/udpqueue.c
--- dgd/doc/net/udpqueue.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/doc/net/udpqueue.c	2009-02-13 23:59:26.000000000 +0100
@@ -0,0 +1,71 @@
+#define UDP_RINGBUF_SIZE 64
+
+private mixed *buffer;
+private int   read_pos;
+private int   write_pos;
+private int   udp_sending;
+
+/*
+ * Setup the buffer
+ */
+private void initialize_udp_buffer() {
+  buffer = allocate(UDP_RINGBUF_SIZE);
+  read_pos = 0;
+  write_pos = 0;
+  udp_sending = 0;
+}
+
+/*
+ * Send the next datagram in the queue
+ */
+private void send_queued_packet() {
+  mixed * datagram;
+
+  if(read_pos != write_pos) {
+    datagram = buffer[read_pos];
+    if(datagram) ::send_datagram(datagram[0], datagram[1], datagram[2]);
+    buffer[read_pos] = nil;
+    read_pos++;
+    if(read_pos == UDP_RINGBUF_SIZE) {
+      read_pos = 0;
+    }
+  } else {
+    udp_sending = 0;
+  }
+}
+
+/*
+ * Called by the driver when its done.
+ */
+nomask static void datagram_done() {
+  send_queued_packet();
+}
+
+/*
+ * Send a datagram to some destination.
+ * Returns the number of datagrams in the queue
+ */
+nomask static int send_datagram(string data, string ip, int port) {
+  int count;
+
+  if(!buffer) initialize_udp_buffer();
+
+  if(write_pos == read_pos-1 || (read_pos == 0 && write_pos == UDP_RINGBUF_SIZE-1)) {
+    error("UDP send buffer full");
+  }
+
+  buffer[write_pos] = ({ data, ip, port });
+  write_pos++;
+  if(write_pos == UDP_RINGBUF_SIZE) {
+    write_pos = 0;
+  }
+
+  if(!udp_sending) {
+    udp_sending = 1;
+    send_queued_packet();
+  }
+
+  count = (write_pos - read_pos) % UDP_RINGBUF_SIZE; 
+  if(count < 0) count += UDP_RINGBUF_SIZE + 1; 
+  return count;
+}
diff -ruN dgd/I3/00README dgd-net/I3/00README
--- dgd/I3/00README	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/00README	2008-05-19 21:21:47.000000000 +0200
@@ -0,0 +1,21 @@
+The files in this directory should be helpful for
+implementing an Intermud 3 client on DGD.
+
+Both come from my private lib, and won't work directly
+with the kernel lib, but should be easy to adapt.
+
+Part of the code comes from Gurbalib, with thanks to Erlend for
+letting me use it.
+
+mudmode.c         is a connection object to handle mudmode connects,
+                  it can be switched to raw mode in order to support
+                  the I4 specs being discussed.
+
+saverestore_var.c is a library to implement the MudOS save_variable
+                  and restore_variable efuns. It is needed by the
+                  mudmode connection object.
+
+On top of this, you will need an I3 client, Gurbalib contains one
+that can serve as a sample. I hope to release my own client sometime,
+but unlike the above 2 files, it is heavily tied into my own lib and
+won't work very well as a starting point.
diff -ruN dgd/I3/mudmode.c dgd-net/I3/mudmode.c
--- dgd/I3/mudmode.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/mudmode.c	2008-05-19 21:21:47.000000000 +0200
@@ -0,0 +1,315 @@
+/*
+ * MudOS mudmode connection emulator for DGD
+ *
+ * Based on fragments from Gurbalib and the DGD Kernel lib.
+ *
+ * This type of connection allows you to send LPC variables
+ * between MUDs. 
+ *
+ * by Aidil of Way of the Force.
+ */
+
+#define DBT(X) if(find_player("aidil")) find_player("aidil")->tell(X+"\n");
+# include <config.h>
+# include <limits.h>
+# include <privilege.h>
+# include <network.h>
+
+inherit "/kernel/lib/net/connection";
+inherit "/kernel/lib/mudos/saverestore_var";
+
+static atomic void queue_data(mixed data);
+
+object dauser;	        /* associated user object */
+int timestamp;		/* last time something was received */
+string buffer;          /* receive buffer */
+mixed * packets;        /* packet queue   */
+int rawmode;            /* rawmode flag   */
+int packet_len;         /* expected length of the current inbound packet */
+
+/*
+ * NAME:        set_rawmode()
+ * DESCRIPTION: enable/disable raw tcp mode
+ */
+void set_rawmode(int flag) {
+  rawmode = (flag != 0);
+}
+
+/*
+ * NAME:        query_rawmode()
+ * DESCRIPTION: return raw tcp mode status
+ */
+int query_rawmode() {
+  return rawmode;
+}
+
+/*
+ * NAME:	set_user()
+ * DESCRIPTION:	set the user object
+ */
+void set_user(object obj) {
+  if (object_name(previous_object()) == DRIVER || PRIVILEGED() || NETLIB()) {
+    dauser = obj;
+  }
+      
+  if(dauser != obj) error("Failed to set dauser!!!");
+  ::set_user(dauser, "tcp");
+}
+
+/*
+ * NAME:	query_player()
+ * DESCRIPTION:	return the player object
+ */
+object query_user() {
+  return dauser;
+}
+
+/*
+ * NAME:	open()
+ * DESCRIPTION:	start a user connection for this object
+ */
+void open() {
+  if(previous_object() != nil) {
+     error("Illegal call to open\n");
+  }
+  ::open(allocate(DRIVER->query_tls_size()));
+  rlimits(MAXDEPTH; MAXTICKS) {
+    timestamp = time();
+    set_this_player(dauser);
+    dauser->_F_connection(this_object());
+    dauser->_F_call("open");
+  }
+}
+
+/*
+ * NAME:	close(varargs int dest)
+ * DESCRIPTION:	close the user connection of this object
+ */
+static void close(varargs int dest) {
+  ::close(allocate(DRIVER->query_tls_size()),dest);
+}
+
+/*
+ * NAME:	force_close()
+ * DESCRIPTION:	forcibly close the user connection
+ */
+void force_close() {
+  if (!previous_object() || previous_object() == dauser || PRIVILEGED() || NETLIB() || object_name(previous_object()) == DRIVER) {
+    dauser->force_close();
+    dauser = nil;
+    catch(destruct(this_object()));
+  }
+}
+
+/*
+ * NAME:	message()
+ * DESCRIPTION:	convert variable to bytestream and send it to the network
+ */
+int message(mixed data) {
+  string str;
+  int size;
+
+  if (previous_object() != dauser || data == 0) {
+    return 0;
+  }
+
+  if(!rawmode) {
+    size = strlen(str = save_variable(data)) + 1;
+
+    str = "    " + str + " ";
+
+    str[0] = (size & 0xff000000) >> 24;
+    str[1] = (size & 0xff0000) >> 16;
+    str[2] = (size & 0xff00) >> 8;
+    str[3] = size & 0xff;
+
+    str[strlen(str)-1] = 0;
+  } else {
+    if(stringp(data)) {
+      str = data;
+    } else {
+      error("Invalid data for raw tcp mode send.\n");
+    }
+  }
+  return ::message(str);
+}
+
+/*
+ * NAME:	process_message()
+ * DESCRIPTION:	process received bytestream from the network, restore variables in it
+ *              and add them to the queue for the user object
+ */
+static void process_message(mixed *tls,string str) {
+  /*
+   * If we had no input, return here;
+   */
+  if(str == nil) return;
+
+  /*
+   * If we are in raw mode, just send whatever we get to the user object
+   * and return
+   */
+  if(rawmode) {
+    queue_data(str);
+    return;
+  }
+
+  /*
+   * Initialize the buffer if it doesn't exist yet.
+   */
+  if(!buffer) {
+    buffer = "";
+    packet_len = 0; /* We had no data so reset this as well */
+  }
+
+  /*
+   * Decode the packets, note that sending each seperate packet to the
+   * user object is handled by send_data which runs with its own
+   * rlimits
+   */
+  rlimits (MAXDEPTH; MAXTICKS) {
+    string packet;
+    int size;
+
+    /*
+     * Make sure the combined input doesn't exceed our max string size.
+     * This also serves to resync the connection after a while in case
+     * we failed to detect the end of the previous package.
+     * Buffer and expected packet size are reset here.
+     */
+    if( strlen( buffer ) + strlen( str ) > MAX_STRING_SIZE ) {
+      buffer = "";
+      packet_len = 0;
+      return;
+    }
+
+    /*
+     * add the input data to our receive buffer.
+     */
+    buffer += str;
+    size = strlen(buffer);
+
+    /* Do we have the 4 bytes for the packet size and possibly the entire packet? */
+    while(size >= packet_len + 4) {
+      packet_len = buffer[3] + (buffer[2] << 8) + (buffer[1] << 16) + (buffer[0] << 24);
+
+      /* Do we really have a complete packet? */
+      if(packet_len + 4 <= size) {
+        /*
+         * extract packet from the buffer, excluding the size and
+         * trailing 0
+         */
+        packet = buffer[4..packet_len+2];
+        /*
+         * remove current packet from the buffer
+         * note that we skip the trailing zero
+         * from the previous packet here.
+         */
+        if(size > packet_len + 4) {
+          buffer = buffer[packet_len+4..];
+        } else {
+          buffer = "";
+        }
+        /*
+         * reset size to the current length of the buffer
+         */
+        size = strlen(buffer);
+        /*
+         * set packet length to zero, will be set to something more useful during next
+         * iteration of this loop, provided there are at least 4 bytes in the buffer.
+         */
+        packet_len = 0; 
+        /*
+         * restore the variable in the packet and send it to the user object.
+         */
+        rlimits(MAXDEPTH;MAXTICKS) {
+          queue_data(restore_variable(packet));
+        } 
+      } 
+    }
+  }
+}
+
+/*
+ * NAME: receive_message()
+ * DESCRIPTION: receive a packet from the network
+ */
+static void receive_message(string str) {
+  process_message(allocate(DRIVER->query_tls_size()),str);
+}
+
+/*
+ * retrieve a converted packet from the queue
+ */
+static atomic mixed next_packet() {
+  mixed packet;
+
+  if(!packets || !sizeof(packets)) {
+    error("Queue is empty.\n");
+  } else {
+    packet = packets[0];
+  }
+
+  if(sizeof(packets) > 1) {
+    packets = packets[1..];
+  } else {
+    packets = ({});
+  }
+  return packet;
+}
+
+/*
+ * NAME:        send_data()
+ * DESCRIPTION: call_out loop to send packets to the user object one at a time, and
+ *              each in its own thread.
+ */
+void send_data() {
+  mixed packet;
+
+  if(!PRIVILEGED()) return;
+  if(packets && sizeof(packets)) {
+    packet = next_packet();
+    catch(set_this_player(dauser));
+    timestamp = time();
+    /*
+     * Start the call_out for the next packet before sending the
+     * current one to the user, this to make sure that a runtime
+     * error won't prevent sending the remaining data.
+     */
+    if(sizeof(packets)) call_out("send_data",0);
+    dauser->receive_message(packet);
+  }
+}
+
+/*
+ * NAME:        queue_data()
+ * DESCRIPTION: queue a variable for the user object.
+ */
+static atomic void queue_data(mixed data) {
+  if(data) {
+    if(!packets) {
+      packets = ({data});
+    } else {
+      packets += ({data});
+    }
+    if(find_call_out("send_data") == -1) {
+      call_out("send_data",0);
+    }
+  }
+}
+
+void connect(string ip, int port) {
+  if(previous_object() == dauser) {
+    ::connect(ip,port);
+  }
+}
+
+void close_user() {
+  if(previous_object() == dauser) {
+    destruct_object(this_object());
+  }
+}
+
+void receive_error(string message) {
+  DBT("ERROR: "+message);
+}
diff -ruN dgd/I3/router/00Copyright dgd-net/I3/router/00Copyright
--- dgd/I3/router/00Copyright	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/00Copyright	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,7 @@
+The code in this directory is Copyright 2008 by Bart van Leeuwen
+(aidil@wotf.org)
+
+Permission is granted to use this code in any way you like and for
+(re)distributing it or modified versions of it, provided this copyright
+message and credits in file headers are preserved.
+
diff -ruN dgd/I3/router/00README dgd-net/I3/router/00README
--- dgd/I3/router/00README	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/00README	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,11 @@
+Intermud 3 + IRN router
+
+This is a copy of the Intermud 3 and IRN code that is
+used on the *wpr public intermud 3 router.
+
+This code is provided as an example, it uses some
+functionality provided by the WOTF kernel that is not
+available on DGD's kernel library directly.
+
+Documentation of the network protocols used by this
+code can be found at http://wotf.org/i3/
diff -ruN dgd/I3/router/daemon/I3_router.c dgd-net/I3/router/daemon/I3_router.c
--- dgd/I3/router/daemon/I3_router.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/daemon/I3_router.c	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,1254 @@
+/*
+ * The I3 router
+ * This object serves 'user' objects for each connection, keeps track of them,
+ * and allows sending data between them.
+ *
+ * It also supports the intermud 3 irn protocol.
+ *
+ * This is a long and windy piece of code, it should be split up.. not for today.
+ *
+ * Aidil @ Way of the Force.
+ */
+
+# include <config.h>
+# include <limits.h>
+# include <type.h>
+# include <intermud3.h>
+# include <i3spec.h>
+# include <pathnames.h>
+# include <loglevels.h>
+
+inherit netlib  "/system/lib/net/net";
+inherit mudlist "/system/lib/router/mudlist";
+inherit irnsrv  "/system/lib/router/irnv1srv";
+
+# include <router.h>                    /* also contains prototypes, needs to be after all inherit statements */
+
+static mapping peers;                   /* mapping between peer name and their 'user' objects */
+static object driver;                   /* driver object */
+static int lasterror;                   /* last error we got */
+static int lastclean;
+
+string myname;                          /* name of this router */
+string mypass;
+string netname;                         /* name of our network, used to communicate with local intermud daemon */
+mapping chandata;
+mapping routerlist;                     /* router list */
+int chanlistid;
+int irnchanlistid;
+int DBL;
+
+void init_routerlist();
+
+static void save_me() {
+  save_object(SAVEFILE);
+}
+
+static int restore_me() {
+  return restore_object(SAVEFILE);
+}
+
+void enable_debug(int flag) {
+  DBL = DBL | flag;
+  mudlist::set_mudlist_dbl(DBL);
+  irnsrv::set_irn_dbl(DBL);
+}
+
+void disable_debug(int flag) {
+  DBL = DBL & (0xFF ^ flag);
+  mudlist::set_mudlist_dbl(DBL);
+  irnsrv::set_irn_dbl(DBL);
+}
+
+int query_debug() {
+  return DBL;
+}
+
+static void create() {
+    netlib::create();
+    driver = find_object(DRIVER);
+    seteuid(getuid());
+    if(!restore_me()) {
+      myname = NAME;
+      netname = "yatmim";
+      init_routerlist();
+    }
+
+    mypass = MYPASS;
+
+    mudlist::create();
+    mudlist::set_myname(myname);
+    mudlist::set_mudlist_dbl(DBL);
+    save_me();
+
+    set_handler(HANDLER);
+    open_port("mudmode", PORT);   
+    peers = ([]);
+    irn = ([]);
+    NETWORK->add_listener();
+    call_out("start_client",5);
+    call_out("periodic",60);
+}
+
+static mapping i3_nodes() {
+  return peers;
+}
+
+static string *i3_node_names() {
+  return m_indices(peers);
+}
+
+static object *i3_node_objects() {
+  return m_values(peers);
+}
+
+static string query_mypass() { return mypass; }
+static string query_myname() { return myname; }
+
+static void start_client() {
+  object ob;
+  string * routers;
+  int i;
+
+  routers = m_indices(routerlist);
+
+  for(i=0;i<sizeof(routers);i++) {
+    if(routers[i] != myname && !irn[routers[i]]) {
+      start_irn_con(routers[i]);
+    }
+  }
+}
+
+string query_nodename() { return myname; }
+int query_localsrc() { return 1; }
+int query_irn() { return 1; }
+
+object connection(string ip, int port)
+{
+    return ::connection(allocate(driver->query_tls_size()), ip, port, "tcp");
+}
+
+void done() {
+    close_user();
+}
+
+/*
+ * NAME:	open()
+ * DESCRIPTION:	open the connection
+ */
+static int open(int port) {
+    ::open(allocate(driver->query_tls_size()), port);
+    return 0;
+}
+
+/*
+ * NAME:	close()
+ * DESCRIPTION:	close the connection
+ */
+static void close(int force) {
+    ::close(allocate(driver->query_tls_size()), force);
+}
+
+static void close_peer(object p) {
+  p->force_disconnect();
+}
+
+static void destroying() {
+
+  NETWORK->remove_listener();
+  broadcast_packet( ({ "router-shutdown", 5, myname, 0, 0, 0, 60 }),0 );
+/*
+  filter_array(m_values(peers)+m_values(irn),"close_peer",this_object());
+*/
+  filter_array(HANDLER->query_clone_list(),"close_peer",this_object());
+  NETWORK->remove_listener();
+  IMUDWARN("Destructed router object\n");
+  mudlist::destroying();
+  save_me();
+}
+
+static void register_node(object o,string n) {
+  if(!peers) peers = ([]);
+  o->set_nodename(n);
+  o->set_irn(0);
+  o->set_localsrc(1);
+  peers[n]=o;
+  muddata[n]["lastip"] = query_ip_number(o);
+  muddata[n]["router"] = myname;
+  muddata[n]["delay"] = -1;
+  IMUDLOG(n+" connected from "+query_ip_number(o));
+}
+
+static int authenticate_node(object con, mixed *data) {
+  string src,dst;
+  int version;
+  mapping md;
+  
+  IMUDDEBUG(DEBUG_AUTH,"Authentication request from "+query_ip_number(con));
+  IMUDDEBUG(DEBUG_DATA,sprintf("%y\n",data));
+  if(sizeof(data) < 7) return ERROR_BAD_PACKET;
+
+  src = (data[2] ? data[2]:nil);
+  dst = (data[4] ? data[4]:nil);
+
+  IMUDDEBUG(DEBUG_AUTH,"Claims to be "+(src ? src:"<NO NAME>"));
+
+  if(!src) {
+    return ERROR_BAD_SOURCE;
+  }
+
+  if(src == "Mudfarm Lima" && dst == "*wir") dst = "*war";
+
+  if(dst != myname) {
+    IMUDDEBUG(DEBUG_AUTH,"bad destination for auth packet: "+dst);
+    return ERROR_INVALID_DESTINATION;
+  }
+
+  sscanf(data[0],"startup-req-%d",version);
+
+  md = get_muddata(src);
+
+  if(!md) {
+    md = ([
+      "router":myname,
+      "password":random(INT_MAX),
+      "connect_time":time(),
+      "disconnect_time":0,
+      "version":version,
+      "lastip":query_ip_number(con),
+      "public":data[7..],
+      "delay":-1
+    ]);
+    IMUDDEBUG(DEBUG_AUTH,"registering new node "+src);
+  } else {
+    int pw;
+    string ip;
+
+    pw = md["password"];
+#ifdef PUBLIC_ROUTER
+    ip = query_ip_number(con);
+    if(ip != md["lastip"] && data[6] != pw) {
+#else
+    if(data[6] != pw) {
+#endif
+      IMUDDEBUG(DEBUG_AUTH,"Bad password");
+      IMUDERROR("Bad password from "+src+" ("+query_ip_number(previous_object())+")");
+      return ERROR_PERMISSION_DENIED;
+    } else {
+      IMUDDEBUG(DEBUG_AUTH,"Authenticated node "+src);
+      md = ([
+      "router":myname,
+      "connect_time":time(),
+      "disconnect_time":0,
+      "version":version,
+      "lastip":query_ip_number(con),
+      "public":data[7..],
+      "password":pw,
+      "delay":-1
+      ]);
+
+    }
+  }
+  store_muddata(src,md);
+  irn_broadcast_mudlist_change(src);
+  register_node(con,src);
+  save_me();
+}
+
+static mapping query_router_list() {
+  return routerlist ? routerlist[..]:([]);
+}
+
+static mixed * filtered_routerlist() {
+  int i;
+  mixed * ret, rnames;
+
+  ret = ({ });
+
+  rnames = m_indices(routerlist);
+
+  for(i=0;i<sizeof(rnames);i++) {
+    if(rnames[i] == myname) 
+    ret += ({
+      ({ 
+        rnames[i],  
+        routerlist[rnames[i]][0] + " " + routerlist[rnames[i]][1]
+      })
+    });
+  }
+  return ret;
+}
+
+object find_node(string n, varargs int route) {
+  /*
+   * This object is a node as well for directed requests
+   */
+  if(myname && n == myname) {
+    return this_object();
+  } else if(peers[n]) {
+    return peers[n];
+  } else if(route && muddata[n] && muddata[n]["delay"] == -1) {
+    string rname;
+    object con;
+    rname = muddata[n]["router"];
+    if(rname) con = find_irn(rname);
+    return con;
+  }
+}
+
+static int allow_packet(object con, mixed * packet) {
+  /*
+   * set lasterror to something. The code below will have to clear it
+   */
+  lasterror = ERROR_BAD_PACKET;
+
+  if(!stringp(packet[0])) {
+    lasterror = ERROR_BAD_PACKET;
+  /*
+   * refuse packets from bad sites outright.
+   */
+  } else if(NETWORK->query_bad_site(query_ip_number(con)) > 3) {
+    IMUDERROR("packet from banned site "+query_ip_number(con));
+    lasterror = ERROR_BANNED;
+  /*
+   * Authenticate startup-req-* packets
+   */
+  } else if(!con->query_nodename() && sscanf(packet[0],"startup-req-%*d") == 1) {
+    lasterror = authenticate_node(con,packet);
+  /*
+   * Authenticate irn-startup-req packets
+   */
+  } else if(!con->query_nodename() && packet[0] == "irn-startup-req") {
+    lasterror = authenticate_irn(con,packet);
+  } else {
+    lasterror = 0;
+  }
+
+  if(!lasterror && !con->query_nodename()) {
+    IMUDDEBUG(DEBUG_CORE,sprintf("Unauthenticated packet on %s : %y",query_ip_number(con),packet));
+    lasterror = ERROR_NOT_AUTHENTICATED;
+  }
+
+  if(packet[2] == "Mudfarm Lima" && packet[4] == "*wir") packet[4] = "*war";
+
+  if(!lasterror) {
+    /*
+     * If this is an irn packet, check that the sending node is
+     * 1. an irn node
+     * 2. the originator of the packet.
+     * Also check that we are the intended destination.
+     */
+    if(sscanf(packet[0],"irn-%*s") == 1) {
+      if(!con->query_irn() || packet[2] != con->query_nodename()) {
+        IMUDDEBUG(DEBUG_IRN,"irn packet from non irn peer or bad name");
+        lasterror = ERROR_BAD_SOURCE;
+      } else if(packet[4] != myname && packet[4] != "*") {
+        IMUDDEBUG(DEBUG_IRN,"irn packet for another router");
+        lasterror = ERROR_INVALID_DESTINATION;
+      } else {
+        lasterror = 0;
+      }
+    /*
+     * not an irn packet, check sending mud/router against the packet
+     */
+    } else if(con->query_nodename() == packet[2]) {
+      lasterror = 0;
+    /*
+     * Not any of the above, seems some mud is trying to spoof something here.
+     */
+    } else {
+      IMUDERROR(con->query_nodename()+" is trying to spoof "+packet[2]);
+      lasterror = ERROR_BAD_SOURCE;
+    }
+  /*
+   * Allow errors even when not authenticated, they might tell us why :)
+   */
+  } else if(packet[0] == "error") {
+    lasterror = 0;
+  }
+
+#ifdef I3_VALIDATE_PACKETS
+  if(!lasterror) {
+    if(PSTYPE[packet[0]]) {
+      mixed * data;
+      int i,m;
+      data = packet[6..];
+      m = sizeof(PSTYPE[packet[0]]);
+      if(sizeof(data) != m) {
+        lasterror = ERROR_BAD_PACKET;
+        IMUDWARN("Bad packet size for "+packet[0]+" packet from "+packet[2]);
+      } else {
+        for(i=0;i<m;i++) {
+          if(data[i] != 0 && _typeof(data[i]) != PSTYPE[packet[0]][i]) {
+            lasterror = ERROR_BAD_PACKET;
+            IMUDWARN("Bad type for field "+PSNAME[packet[0]][i]+" in "+packet[0]+" packet from "+packet[2]);
+          }
+        }
+      }
+    }
+  }
+#endif
+  return !lasterror;
+}
+
+static mixed * mangle_packet(mixed * packet) {
+  /*
+   * Encapsulated i3 packet aimed at us (or all routers), decode.
+   */
+  if(packet[0] == "irn-data" && (packet[4] == "*" || packet[4] == myname)) {
+    IMUDDEBUG(DEBUG_DATA,"Translating inbound irn-data packet from "+packet[2]);
+    packet = packet[6];
+  }
+  return packet;
+}
+
+static int send_to_node(object p, mixed * data, varargs int route) {
+  int r;
+  int i;
+
+  if(!route) route = 0;
+  for(i=0;i<sizeof(data);i++) {
+    if(data[i] == nil) error("ELEMENT "+i+" IS NILL" + sprintf("%y",data[..i-1]));
+  }
+  if(p == this_object() || data[4] != 0 || p->test_service_available(data[0])) {
+    IMUDDEBUG(DEBUG_DATA,sprintf("send_to_node %y (%y): %y\n",p,p->query_nodename(),data));
+    if(p == this_object()) {
+      p->receive_router_data(data,route);
+    } else if(p->query_irn()) {
+      if(sscanf(data[0],"irn-%*s") != 1) {
+        data = ({"irn-data",5,myname,0,"*",0,data});
+      }
+      p->receive_router_data(data);
+    } else {
+      p->receive_router_data(data);
+    }
+  }
+}
+
+static int broadcast_packet(mixed * data, int localsrc) {
+  object * targets;
+  
+  targets = m_values(peers);
+  if(localsrc) targets += m_values(irn);
+  IMUDDEBUG(DEBUG_TRANSMIT,sprintf("Broadcasting %s packet from %s to %y",data[0],(data[3] ? data[3]+"@":"")+data[2],m_indices(peers)));
+  targets = filter_array(targets,"send_to_node",this_object(),data);
+  return targets && sizeof(targets);
+}
+
+static int multicast_packet(string * destination, mixed *data, int localsrc) {
+  int i;
+  int route;
+
+#ifndef IRN_MULTICAST
+  route = localsrc;
+#endif
+  IMUDDEBUG(DEBUG_TRANSMIT,sprintf("Multicasting %s from '%s' for '%s' to %y",data[0],(data[3] ? data[3]+"@":"")+data[2],data[5] ? (data[4] ? data[4]+"@":"")+data[5]:"0",destination));
+  for(i=0;i<sizeof(destination);i++) {
+    if(find_node(destination[i],route)) {
+      send_to_node(find_node(destination[i],route),data[0..3]+({destination[i],0})+data[6..],localsrc);
+    }
+  }
+#ifdef IRN_MULTICAST
+  if(localsrc) {
+    int c;
+    for(c=0;c<sizeof(m_values(irn));c++) {
+      if(m_values(irn)[c] != this_object()) {
+        send_to_node(m_values(irn)[c],data,localsrc);
+      }
+    }
+  }
+#endif
+}
+
+static int send_packet(string destination, mixed *data, int route) {
+  object target;
+
+  target = find_node(destination,route);
+  IMUDDEBUG(DEBUG_TRANSMIT,sprintf("Sending %s packet from '%s' for '%s' to '%s'",data[0],(data[3] ? data[3]+"@":"")+data[2],(data[5] ? data[5]+"@":"")+data[4],(target ? target->query_nodename():"<NONE")));
+
+  if(target) {
+    lasterror = send_to_node(target,data,route);
+  } else {
+    if(muddata[destination]) {
+      if(query_queue_time(destination)) {
+        lasterror = ERROR_TMP_DOWN;
+      } else {
+        lasterror = ERROR_DOWN;
+      }
+    } else {
+      lasterror = ERROR_BAD_DESTINATION;
+    }
+  }
+  return !lasterror;
+}
+
+static void send_error(object con, string * err, mixed * data) {
+  IMUDDEBUG(DEBUG_CORE,"Sending error "+(err[0] ? ""+err[0]:"<NIL>")+":"+(err[1]? err[1]:"<NIL>")+" to "+(con->query_nodename() ? con->query_nodename():"<NOT AUTHENTICATED>"));
+  con->receive_router_data( ({"error",5,myname,0,data[2],data[3],err[0],err[1],data}) );
+}
+
+int route_packet(mixed * data) {
+  object target;
+  int * results, localsrc;
+  mixed destination;
+
+  lasterror = 0;
+
+  if(!(object HANDLER) previous_object() && previous_object() != this_object()) {
+    error("Illegal call to route_packet()");
+  }
+
+  localsrc = previous_object()->query_localsrc() ? 1:0;
+  IMUDDEBUG(DEBUG_CORE,sprintf("Packet from IP %y: %y (%y) %s",query_ip_number(previous_object()),previous_object(),previous_object()->query_nodename(),(localsrc ? "local":"irn")));
+  if(!data || sizeof(data) < 6) {
+    lasterror = ERROR_BAD_PACKET;
+  } else if(allow_packet(previous_object(), data)) {
+    if(muddata[data[2]]) muddata[data[2]]["lastseen"] = time();
+
+    data = mangle_packet(data);
+    IMUDDEBUG(DEBUG_DATA,sprintf("Processing %y",data));
+    if(sscanf(data[0],"channel-%*s") == 1) {
+      destination = myname;
+    } else {
+      destination = (data[4] ? data[4]:nil);
+    }
+    IMUDDEBUG(DEBUG_CORE,data[0]+" for "+(destination ? destination:"<BROADCAST>"));
+    if(destination) {
+      if(stringp(destination)) {
+        send_packet(destination,data,localsrc);
+      } else if(pointerp(destination)) {
+        multicast_packet(destination,data,localsrc);
+      } else {
+        lasterror = ERROR_BAD_DESTINATION;
+      }
+    } else {
+      broadcast_packet(data,localsrc);
+    }
+  } else {
+    IMUDDEBUG(DEBUG_CORE,sprintf("Refused : %y",data));
+  }
+
+  if(lasterror && localsrc) {
+    IMUDWARN(ERRORDATA[lasterror][1]+sprintf(" %y",data));
+    send_error(previous_object(),query_error_data(),data+({}));
+  } else if(lasterror && data[2] == previous_object()->query_nodename()) {
+    IMUDWARN(ERRORDATA[lasterror][1]+sprintf("IRN: %y",data));
+    send_error(previous_object(),query_error_data(),data+({}));
+  } else {
+    return 1;
+  }
+}
+
+static int send_from_router(string ptype, mixed destmud, mixed destuser, mixed * data, varargs int route) {
+  if(destmud == nil) destmud = 0;
+  if(destuser == nil) destuser = 0;
+  
+  if(!destmud || destmud == 0) {
+    broadcast_packet( ({ ptype, 5, myname, netname, 0, 0 }) + data,route);
+  } else if(stringp(destmud)) {
+    send_packet( destmud, ({ ptype, 5, myname, netname, destmud, destuser }) + data , route);
+  } else if(pointerp(destmud)) {
+    multicast_packet( destmud, ({ ptype, 5, myname, netname, 0, 0 }) + data , route);
+  }
+  return lasterror;
+}
+
+static int send_notice(mixed destmud, mixed destuser, mixed * data, varargs int route) {
+  string ptype;
+
+  ptype = "notice";
+  if(destmud == nil) destmud = 0;
+  if(destuser == nil) destuser = 0;
+
+  IMUDDEBUG(DEBUG_SERVICES,"Sending notice to "+destuser+"@"+(arrayp(destmud) ? implode(destmud,", "):destmud));
+
+  if(!destmud || destmud == 0) {
+    broadcast_packet( ({ ptype, 5, myname, netname, 0, 0 }) + data,route);
+  } else if(stringp(destmud)) {
+    send_packet( destmud, ({ ptype, 5, myname, netname, destmud, destuser }) + data , route);
+  } else if(pointerp(destmud)) {
+    multicast_packet( destmud, ({ ptype, 5, myname, netname, 0, 0 }) + data , route);
+  }
+  return lasterror;
+}
+
+
+int query_errno() { return lasterror; }
+
+string * query_error_data(varargs int errno) {
+ if(!errno) errno = lasterror;
+ if(errno >= sizeof(ERRORDATA)) errno = 0;
+  return ERRORDATA[errno]; 
+}
+
+/*
+ * Handle requests for the router
+ */
+
+
+/*
+ * This is called by the low level routing process to deliver
+ * data to us.
+ */
+static int receive_router_data(mixed data, varargs int route) {
+  string ptype,func;
+
+#ifdef IRN_DESPAM_PING
+  if(data[0] != "irn-ping") {
+#endif
+  IMUDDEBUG(DEBUG_SERVICES,sprintf("%s packet from %s arrived at service handling",data[0],(stringp(data[3]) ? data[3]+"@":"")+data[2]));
+  IMUDDEBUG(DEBUG_DATA,sprintf("%y",data));
+#ifdef IRN_DESPAM_PING
+  }
+#endif
+  ptype = data[0];
+  func = router_services[ptype];
+  if(func && function_exists(func,this_object())) {
+#ifdef IRN_DESPAM_PING
+    if(data[0] != "irn-ping")
+#endif
+    IMUDDEBUG(DEBUG_SERVICES,"Calling "+func);
+    return call(func,data,route);
+  } else {
+#ifdef IRN_DESPAM_PING
+    if(data[0] != "irn-ping")
+#endif
+    IMUDDEBUG(DEBUG_SERVICES,"Unhandled packet");
+    return ERROR_BAD_PACKET;
+  }
+}
+
+static int test_connected(string mud) {
+  return muddata[mud] && 
+         muddata[mud]["connect_time"] && 
+         !muddata[mud]["disconnect_time"] &&
+         (muddata[mud]["router"] && (muddata[mud]["router"] == myname || irn[muddata[mud]["router"]])) ;
+}
+
+/*
+ * Reply to a startup request
+ */
+static int rcv_startup_req(mixed * data, varargs int route) {
+  string mud;
+  int version;
+
+  mud = (data[2] ? data[2]:nil);
+  if(!mud || sizeof(data) < 19) {
+    return ERROR_BAD_PACKET;
+  }
+
+  IMUDDEBUG(DEBUG_SERVICES,"sending startup reply to "+mud);
+
+  sscanf(data[0],"startup-req-%d",version);
+  find_node(mud)->set_protocol_version(version);
+  send_from_router("startup-reply",mud,0,({filtered_routerlist(),muddata[mud]["password"]}));
+
+  if(!lasterror) {
+    if(mappingp(data[18])) {
+      find_node(mud)->set_services(data[18]);
+    }
+    if(mappingp(data[19])) {
+      if(data[19]["imud_version"]) {
+        version=data[19]["imud_version"];
+        find_node(mud)->set_protocol_version(version);
+      }
+    }
+
+/*
+    if(query_queue_time(mud)) {
+      dequeue_mudlist_changed(mud);
+      irn_broadcast_mudlist_change(mud);
+    } else {
+      mudlist_changed(mud,1,1);
+    }
+*/
+
+    call_out("send_mudlist",0,mud,data[7]);
+    call_out("send_chanlist",0,mud);
+    send_notice(({"Way of the Force","The Zone","WOTF Devel"}),0,({mud+" connected from "+muddata[mud]["lastip"]+" using the I3 version "+version+" protocol"}),1);
+    return 0;
+  }
+  return lasterror;
+}
+
+static int rcv_shutdown(mixed * data, varargs int route) {
+  string mud;
+
+  if(sizeof(data) != 7) {
+    return ERROR_BAD_PACKET;
+  }
+
+  if(peers[data[2]]) {
+    if(muddata[data[2]]) {
+      muddata[data[2]]["delay"] = data[6];
+    }
+    peers[data[2]]->force_disconnect();
+  }
+}
+
+static int rcv_mudlist_req(mixed * data, varargs int route) {
+  IMUDDEBUG(DEBUG_SERVICES,"rcv_mudlist_req");
+  return send_mudlist(data[2], muddata[data[2]]["public"][0]);
+}
+
+static int test_allow_on_channel(string mud, string channel) {
+  switch(chandata[channel][1]) {
+    case 0 : return member_array(mud,chandata[channel][2]) == -1;
+    case 1 :
+    case 2 : return member_array(mud,chandata[channel][2]) != -1;
+  }
+}
+
+static int send_irn_chanlist_delta(string channel, varargs int nochan, int nolisten) {
+  mapping data;
+  int i;
+  object * router;
+
+  data = ([]);
+  if(!nochan) {
+    data["channels"] = ([ channel : (chandata[channel] ?  ({ chandata[channel][1], chandata[channel][0], chandata[channel][2] }):0) ]);
+  }
+  if(!nolisten) {
+    data["listening"] = ([ channel : (chandata[channel] ? chandata[channel][3]:({})) ]);
+  }
+
+  router = m_values(irn);
+  for(i=0;i<sizeof(router);i++) {
+    send_to_node(
+      router[i], 
+      ({
+        "irn-chanlist-delta",
+        5,
+        myname,
+        0,
+        router[i]->query_nodename(),
+        0,
+        chanlistid,
+        data
+      })
+    );
+  }
+}
+
+static int rcv_irn_ping(mixed * data, varargs int route) {
+#ifndef IRN_DESPAM_PING
+  IMUDDEBUG(DEBUG_IRN,"Received irn-ping from "+data[2]); */
+#endif
+}
+
+static int rcv_irn_chanlist_delta(mixed * data, varargs int route) {
+  int i,j,k;
+  int irnc,pubc;
+
+  string * tmp;
+  mixed channels;
+  mixed listeners;
+
+  IMUDDEBUG(DEBUG_SERVICES,"rcv_irn_chanlist_delta");
+
+  if(!mappingp(data[7])) {
+    return ERROR_BAD_PACKET;
+  }
+
+  channels = data[7]["channels"];
+  listeners = data[7]["listening"];
+  chanlistid = data[6];
+
+  if(channels) {
+    IMUDDEBUG(DEBUG_SERVICES,"We have channels: "+implode(m_indices(channels),", "));
+    if(!mappingp(channels)) {
+      return ERROR_BAD_PACKET;
+    }
+
+    pubc = 1;
+    tmp = m_indices(channels);
+    for(i=0;i<sizeof(tmp);i++) {
+      if(channels[tmp[i]] == 0) {
+        chandata[tmp[i]] = nil;
+      } else if(!chandata[tmp[i]]) {
+        chandata[tmp[i]] = ({ channels[tmp[i]][1],
+                              channels[tmp[i]][0],
+                              channels[tmp[i]][2],
+                              ({ })
+                           });
+      } else {
+        chandata[tmp[i]] = ({ channels[tmp[i]][1],
+                              channels[tmp[i]][0],
+                              channels[tmp[i]][2],
+                              chandata[tmp[i]][3]
+                            });
+      }
+    }
+  }
+
+  if(listeners) {
+    IMUDDEBUG(DEBUG_SERVICES,"We have listeners");
+    if(!mappingp(listeners)) {
+      return ERROR_BAD_PACKET;
+    }
+    tmp = m_indices(listeners);
+    for(i=0;i<sizeof(tmp);i++) {
+      if(!chandata[tmp[i]]) {
+        /* can't add listeners to a channel we don't have */
+        /* chandata[tmp[i]] = ({ "The Zone",0,({}),({}) }); */
+
+        IMUDWARN("listeners received for "+tmp[i]+" but I don't have that channel!");
+      } else {
+        IMUDDEBUG(DEBUG_SERVICES,"Changing listeners for "+tmp[i]+" to "+sprintf("%y",listeners[tmp[i]]));
+        chandata[tmp[i]][3] = listeners[tmp[i]];
+      }
+    }
+  }
+  save_me();
+  if(pubc) {
+    filter_array(m_indices(channels),"broadcast_chanlist",this_object());
+  }
+}
+
+
+
+/*
+ * Handle channel requests
+ */
+static int rcv_channel(mixed * data, varargs int route) {
+  string cname, *destinations;
+  int i;
+
+  if(sizeof(data) < 7) {
+    IMUDDEBUG(DEBUG_CHANNELS,"Bad packet (bad size)");
+    return ERROR_BAD_PACKET;
+  }
+
+  cname = data[6] ? data[6]:nil;
+  if(!cname) {
+    IMUDDEBUG(DEBUG_CHANNELS,"Bad packet (no channel name)");
+    return ERROR_BAD_PACKET;
+  }
+
+  if(!chandata[cname]) {
+    IMUDDEBUG(DEBUG_CHANNELS,"Unknown channel");
+    send_from_router("error",data[2],data[3],({"unk-channel","The channel "+cname+" is not known here",data}));
+  } else if(!test_allow_on_channel(data[2],cname)) {
+    IMUDDEBUG(DEBUG_CHANNELS,"Not allowed");
+    send_from_router("error",data[2],data[3],({"not-allowed","Your mud is not allowed to use the "+cname+" channel",data}));
+  } else if(chandata[cname]) {
+    IMUDDEBUG(DEBUG_CHANNELS,"Trying to deliver");
+    destinations = chandata[cname][3];
+    if(destinations && sizeof(destinations)) {
+       IMUDDEBUG(DEBUG_CHANNELS,"Delivering "+data[0]+" to "+sprintf("%y",destinations));
+       multicast_packet(destinations,data,0);
+    } else {
+      IMUDDEBUG(DEBUG_CHANNELS,"No listeners?");
+    }
+
+    if(route) {
+      for(i=0;i<m_sizeof(irn);i++) {
+        send_to_node(m_values(irn)[i], data);
+      }
+    }
+  }
+}
+
+static int rcv_chan_adminlist(mixed * data, varargs int route) {
+  mixed src, user, cname;
+
+  if(sizeof(data) != 7) {
+    return ERROR_BAD_PACKET;
+  }
+
+  src = data[2];
+  user = data[3];
+  cname = data[6];
+
+  if(!chandata[cname]) {
+    send_from_router("error",src,user,({"unk-channel","The channel "+cname+" is not known here.",data }) );
+    return 0;
+  }
+
+  if(chandata[cname][0] != src) {
+    send_from_router("error",src,user,({"not-allowed","Only the mud owning "+cname+" is allowed to do that", data}) );
+    return 0;
+  }
+
+  return send_from_router("chan-adminlist-reply",src,user,({ cname, chandata[cname][2] }) );
+  send_irn_chanlist_delta(cname);
+}
+
+static int rcv_channel_listen(mixed * data, varargs int route) {
+  string src,cname;
+  int flag;
+
+  if(sizeof(data) != 8) {
+    return ERROR_BAD_PACKET;
+  }
+
+  src = (data[2] ? data[2]:nil);
+  cname = (data[6] ? data[6]:nil);
+  if(!cname || !src) {
+    return ERROR_BAD_PACKET;
+  }
+  flag = data[7];
+  if(!chandata) chandata = ([]);
+
+  if(chandata[cname]) {
+    chandata[cname][3] -= ({src});
+    if(flag) {
+      if(test_allow_on_channel(src,cname)) {
+        if(member_array(src,chandata[cname][3]) == -1) {
+          chandata[cname][3] += ({src});
+        }
+        save_me();
+        send_irn_chanlist_delta(cname,1,0);
+      } else {
+        send_from_router("error",src,data[3],({"not-allowed","Your mud is not allowed to use that channel",data}));
+      }
+    }
+  }
+}
+
+static int rcv_channel_add(mixed * data, varargs int route) {
+  string src,cname;
+  int mode;
+
+  if(!chandata) {
+    chandata = ([]);
+  }
+
+  if(sizeof(data) != 8) {
+    return ERROR_BAD_PACKET;
+  }
+
+  src = data[2];
+  cname = (data[6] ? data[6]:nil);
+  mode = data[7];
+
+  if(!cname) {
+    return ERROR_BAD_PACKET;
+  }
+
+  if(chandata[cname]) {
+    send_from_router("error",src,data[3],({"not-allowed","The channel "+cname+" already exists.",data}));
+  } else {
+    IMUDLOG("Channel "+cname+" added by "+((data[3] && data[3]) != 0 ? data[3]:"<NONE>")+"@"+src);
+    /* format: "channelname":({"owning mud",mode,({banlist}),({listeners})}) */
+    chandata[cname] = ({src,mode,({}),({})});
+    chanlistid++;
+    save_me();
+    call_out("broadcast_chanlist",0,cname);
+    send_irn_chanlist_delta(cname);
+  }
+}
+
+static int rcv_channel_remove(mixed * data, varargs int route) {
+  string src,cname;
+  int mode;
+
+  if(!chandata) {
+    chandata = ([]);
+  }
+
+  if(sizeof(data) != 7) {
+    return ERROR_BAD_PACKET;
+  }
+
+  src = data[2];
+  cname = (data[6] ? data[6]:nil);
+
+  if(!cname) {
+    return ERROR_BAD_PACKET;
+  }
+
+  if(!chandata[cname]) {
+    send_from_router("error",src,data[3],({"unk-channel","The channel "+cname+" does not exist here.",data}));
+  } else if(chandata[cname][0] != src) {
+    send_from_router("error",src,data[3],({"not-allowed","Your mud does not own the channel "+cname+".",data}));
+  } else {
+    IMUDLOG("Channel "+cname+" removed by "+((data[3] && data[3]) != 0 ? data[3]:"<NONE>")+"@"+src);
+    chandata[cname] = 0;
+    chanlistid++;
+    save_me();
+    call_out("broadcast_chanlist",0,cname);
+    send_irn_chanlist_delta(cname);
+  }
+}
+
+static int rcv_channel_admin(mixed * data, varargs int route) {
+  string src, cname;
+
+  if(sizeof(data) != 9) {
+    return ERROR_BAD_PACKET;
+  }
+
+  src = data[2];
+  cname = (data[6] ? data[6]:nil);
+
+  if(!cname) {
+    return ERROR_BAD_PACKET;
+  }
+
+  if(!chandata[cname]) {
+    send_from_router("error",src,data[3],({"unk-channel","The channel "+cname+" is not known here.",data}));
+  } else if(chandata[cname][0] != src) {
+    send_from_router("error",src,data[3],({"not-allowed","Your mud does not own the channel "+cname+".",data}));
+  } else {
+    IMUDLOG("List for "+cname+" changed by "+((data[3] && data[3]) != 0 ? data[3]:"<NONE>")+"@"+src);
+    if(data[7]) chandata[cname][2] += data[7];
+    if(data[8]) chandata[cname][2] -= data[8];
+    chanlistid++;
+    save_me();
+    call_out("broadcast_chanlist",0,cname);
+    send_irn_chanlist_delta(cname);
+  }
+}
+
+static int rcv_error(mixed * data, varargs int route) {
+}
+
+static int send_chanlist(string where, varargs string cname) {
+  string * channels;
+  int i;
+  mapping result;
+
+  if(!chandata) chandata = ([]);
+  result = ([]);
+  IMUDDEBUG(DEBUG_SERVICES,"Sending channel list for "+(cname ? cname:"all channels")+" to "+where);
+  if(!cname) {
+    channels = m_indices(chandata);
+  } else {
+    channels = ({ cname });
+  }
+  for(i=0;i<sizeof(channels);i++) {
+    if(chandata[channels[i]] != nil) {
+      result[channels[i]] = chandata[channels[i]][..1];
+    } else {
+      result[channels[i]] = 0;
+    }
+  }
+  if(result && m_sizeof(result)) {
+    send_from_router( "chanlist-reply", where, 0, ({ chanlistid, result }) );
+  }
+}
+
+static int check_channel(mixed stuff) {
+  return stuff != 0;
+}
+
+static int broadcast_chanlist(varargs string cname) {
+  string * destinations;
+  destinations = m_indices(peers);
+  if(destinations && sizeof(destinations)) filter_array(destinations,"send_chanlist",this_object(),cname);
+  chandata = filter_mapping(chandata,"check_channel",this_object());
+}
+
+static void notify_mud_removed(string src) {
+  string * channels;
+  int i;
+
+  channels = m_indices(chandata);
+  for(i=0;i<sizeof(channels);i++) {
+    chandata[channels[i]][3] -= ({src});
+  }
+}
+
+
+static int mark_for_router_down(string mud, string router, varargs int flag) {
+  if(muddata[mud] && muddata[mud]["router"] == router && muddata[mud]["delay"] == -1) {
+    muddata[mud]["delay"] = 0;
+    return 1;
+  }
+}
+
+void notify_disconnect() {
+  string mudname;
+
+  if(!(object HANDLER) previous_object()) {
+    error("Illegal call to notify_disconnect()");
+  }
+
+  mudname = previous_object()->query_nodename();
+  IMUDLOG("Mud "+mudname+" disconnected.");
+  if(peers[mudname] && muddata[mudname]["router"] == myname) {
+    peers[mudname]=nil;
+    muddata[mudname]["connect_time"] = 0;
+    muddata[mudname]["disconnect_time"] = time();
+
+    send_notice(({"Way of the Force","The Zone","WOTF Devel"}),0,({mudname+" disconnected."}),1);
+
+    if(muddata[mudname]["delay"] == -1) {
+      IMUDDEBUG(DEBUG_CORE,"notify_disconnect::delay == -1, setting to 0");
+      muddata[mudname]["delay"] = 0;
+      queue_mudlist_changed(mudname);
+      irn_broadcast_mudlist_change(mudname);
+    } else if(muddata[mudname]["delay"] > (7*24*3600)) {
+      IMUDDEBUG(DEBUG_CORE,"notify_disconnect::delay > 7 weeks, removing");
+      muddata[mudname] = nil;
+      mudlist_changed(mudname,1,1);
+    } else if(!muddata[mudname] || muddata[mudname]["delay"] >= 300) {
+      IMUDDEBUG(DEBUG_CORE,"notify_disconnect::delay > 5 minutes, inmediately notify the world.");
+      mudlist_changed(mudname,1,1);
+    } else {
+      IMUDDEBUG(DEBUG_CORE,"notify_disconnect::delay > 0 and < 5 mins");
+      queue_mudlist_changed(mudname);
+      irn_broadcast_mudlist_change(mudname);
+    }
+  }
+}
+
+static int rcv_irn_mudlist_delta(mixed * data, varargs int route) {
+  mapping ml;
+  mapping md;
+  string * muds;
+  int i;
+
+  IMUDDEBUG(DEBUG_IRN,"IRN mudlist delta received from " +data[2]);
+  ml = data[7];
+  muds = m_indices(ml);
+  for(i=0;i<sizeof(muds);i++) {
+    if(ml[muds[i]] == 0) {
+      if(muddata[muds[i]]) {
+        IMUDDEBUG((DEBUG_IRN | DEBUG_SERVICES),"Removing mud "+muds[i]);
+        muddata[muds[i]] = nil;
+        notify_mud_removed(muds[i]);
+        mudlist_changed(muds[i],0,0);
+      } else {
+        IMUDDEBUG((DEBUG_IRN | DEBUG_SERVICES),data[2]+" tried to remove non existing mud "+muds[i]);
+      }
+    } else {
+      md = ml[muds[i]];
+      if(md["connect_time"] == 0 && md["restart_delay"] == -1) {
+        IMUDDEBUG(DEBUG_SERVICES,"Fixing restart_delay of -1 for offline mud "+muds[i]);
+        md["restart_delay"] = 0;
+      }
+
+      if(md["router"] == data[2]) {
+        if(muddata[muds[i]]) {
+          if(intp(md["restart_delay"]) && md["restart_delay"] >= 0 && md["router"] != muddata[muds[i]]["router"]) {
+            IMUDDEBUG((DEBUG_IRN | DEBUG_SERVICES),data[2]+" reports "+muds[i]+" offline but it is currently connected to "+muddata[muds[i]]["router"]);
+          } else {
+            IMUDDEBUG((DEBUG_IRN | DEBUG_SERVICES), "Changing "+" mud "+muds[i]);
+            store_irn_muddata(md);
+            irnmudlistid = data[6];
+          }
+        } else {
+          IMUDDEBUG((DEBUG_IRN | DEBUG_SERVICES), "Adding "+" mud "+muds[i]);
+          store_irn_muddata(md);
+          irnmudlistid = data[6]; 
+        }
+      } else {
+        IMUDDEBUG((DEBUG_IRN | DEBUG_SERVICES),data[2]+" is not currently responsible for "+muds[i]);
+      }
+    }
+  }
+}
+
+static int rcv_irn_startup_req(mixed * data, varargs int route) {
+  string peername;
+
+  IMUDDEBUG(DEBUG_IRN,"IRN startup request received!");
+  peername = data[2];
+  send_irn_mudlist(peername);
+  send_notice(({"Way of the Force","The Zone","WOTF Devel"}),0,({"Router "+peername+" connected."}),1);
+}
+
+static int rcv_irn_data(mixed * data, varargs int route) {
+#ifdef IRNV2
+  object r;
+
+  if(data[1]) {
+    r = find_irn_route(data[2]);
+    if(r) {
+      data[1]--;
+      send_to_node(r,data);
+    }
+  }
+#else
+  IMUDWARN(sprintf("Received irn-data for another router: %y\n",data));
+#endif
+}
+
+object _Q_connection() { return this_object(); }
+
+static int filter_muddata(mapping data) {
+  return !(data["disconnect_time"]) || (data["disconnect_time"] == 0 || (time() - data["disconnect_time"] <= (14 * 24 * 3600))); 
+}
+
+static void expire_pending() { }
+    
+static void periodic() {
+  call_out("periodic",60);
+  if(time() - lastclean >= 3600) {
+    mudlist::do_cleanup();
+    lastclean = time();
+  }
+  expire_pending();
+  run_queue();
+  irn_reconnect();
+}
+
+void upgraded() { 
+}
+
+void remove_mud(string str) {
+  if(peers[str]) peers[str]->force_disconnect();
+  ::remove_mud(str);
+}
+
+void init_routerlist() {
+  routerlist = DEFAULT_ROUTERS;
+  save_me();
+}
+
+void enable_irn_node(string node) {
+  if(routerlist[node]) {
+    routerlist[node][3] = 1;
+    save_me();
+  }
+}
+
+void disable_irn_node(string node) {
+  if(routerlist[node]) {
+    routerlist[node][3] = 0;
+    if(irn[node]) irn[node]->force_disconnect();
+    save_me();
+  }
+}
+
+void set_mypass() { mypass = MYPASS; }
+
+string query_local_muds() {
+  return implode(m_indices(peers),", ")+".\n";
+}
+
+void add_expired(string str) {
+  expired[str] = mudlistid;
+}
+mapping query_muddata() { return muddata; }
+string * query_expired() { return m_indices(expired); }
+string * query_listeners(string str) {
+  if(chandata[str]) {
+    return chandata[str][3];
+  }
+}
+
+void resend_startup_reply(string mud) {
+  if(peers[mud]) {
+    send_from_router("startup-reply",mud,0,({filtered_routerlist(),muddata[mud]["password"]}));
+  }
+}
+
+string * query_irn_connections() { return m_indices(irn); }
+
+string query_netname() {
+  if(netname) return netname;
+  else return "<NONE>";
+}
+
+string * query_local_mud_names() {
+  return m_indices(peers);
+}
+
+string * query_irn_names() {
+  return m_indices(irn);
+}
+
+
diff -ruN dgd/I3/router/include/i3spec.h dgd-net/I3/router/include/i3spec.h
--- dgd/I3/router/include/i3spec.h	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/include/i3spec.h	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ * Format specification of some I3 packets.
+ * If I3_VALIDATE_PACKETS is defined, packets that occur in the PSTYPE mapping
+ * have their data validated on proper types.
+ */
+#define PSTYPE ([\
+  "startup-req-2":({T_INT, T_INT, T_INT, T_INT, T_INT, T_INT, T_STRING, T_STRING, T_STRING, T_STRING, T_STRING, T_STRING, T_MAPPING, T_MAPPING}),\
+  "startup-req-3":({T_INT, T_INT, T_INT, T_INT, T_INT, T_INT, T_STRING, T_STRING, T_STRING, T_STRING, T_STRING, T_STRING, T_MAPPING, T_MAPPING}),\
+  "shutdown":({T_INT}),\
+  "tell":({T_STRING, T_STRING}),\
+  "emote":({T_STRING, T_STRING}),\
+  "who-reply":({T_ARRAY}),\
+  "who_data":({T_ARRAY}),\
+  "user_data":({T_STRING, T_INT, T_STRING}),\
+  "finger-req":({T_STRING}),\
+  "finger-reply":({T_STRING, T_STRING, T_STRING, T_STRING, T_STRING, T_INT, T_STRING, T_STRING, T_STRING}),\
+  "locate-req":({T_STRING}),\
+  "locate-reply":({T_STRING, T_STRING, T_INT, T_STRING}),\
+  "ucache-update":({T_STRING, T_STRING, T_INT}),\
+])
+
+
+#define PSNAME ([\
+  "startup-req-2":({"password","old_mudlist_id","old_chanlist_id","player_port","imud_tcp_port" ,"imud_udp_port","mudlib","base_mudlib","driver","mud_type","open_status","admin_email","services","other_data"}),\
+  "startup-req-3":({"password","old_mudlist_id","old_chanlist_id","player_port","imud_tcp_port","imud_udp_port","mudlib","base_mudlib","driver","mud_type","open_status","admin_email","services","other_data"}),\
+  "shutdown":({"restart_delay"}),\
+  "tell":({"orig_visname","message"}),\
+  "emote":({"orig_visname","message"}),\
+  "who-reply":({"who_data"}),\
+  "who_data":({"user_data"}),\
+  "user_data":({"user_visname","idle_time","xtra_info"}),\
+  "finger-req":({"username"}),\
+  "finger-reply":({"visname","title","real_name","e_mail","loginout_time","idle_time","ip_name","level","extra"}),\
+  "locate-req":({"username"}),\
+  "locate-reply":({"located_mudname","located_visname","idle_time","status"}),\
+  "ucache-update":({"username","visname","gender"}),\
+])
diff -ruN dgd/I3/router/include/intermud3.h dgd-net/I3/router/include/intermud3.h
--- dgd/I3/router/include/intermud3.h	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/include/intermud3.h	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,40 @@
+#ifndef INTERMUD3_DOT_H
+#define INTERMUD3_DOT_H
+
+#include <intermud.h>
+
+#define MUD_NAME  "Way of the Force"
+#define LIB_NAME  "WOTFlib"
+#define LIB_VERSION "0.90"
+
+#define ADMIN_EMAIL ("/kernel/servers/sysconf"->query_admin_email())
+
+#define LOGIN_PORT  3000
+#define I3_TCP_PORT LOGIN_PORT + 2
+#define I3_UDP_PORT LOGIN_PORT + 3
+
+# define ERROR_BAD_PACKET        1
+# define ERROR_PERMISSION_DENIED 2
+# define ERROR_UNKNOWN_SERVICE   3
+# define ERROR_BAD_DESTINATION   4
+# define ERROR_BANNED            5
+# define ERROR_NOT_AUTHENTICATED 6
+# define ERROR_BAD_SOURCE        7
+# define ERROR_TMP_DOWN          8
+# define ERROR_DOWN              9
+# define ERROR_INVALID_DESTINATION 10
+
+#define ERRORDATA  ({({0,0}),\
+                     ({"bad-pkt","Invalid packet"}),\
+                     ({"not-allowed","Permission denied"}),\
+                     ({"unk-type","Unknown packet type"}),\
+                     ({"unk-dst","Unknown destination"}),\
+                     ({"not-allowed","Your IP has been banned temporarely"}),\
+                     ({"bad-proto","You need to authenticate first"}),\
+                     ({"bad-src","Bad source for packet"}),\
+                     ({"unk-dst","Destination is down, it said it would be back shortly"}),\
+                     ({"unk-dst","Destination is down"}),\
+                     ({"unk-dst","Invalid destination for this packet"}),\
+                   })
+
+#endif
diff -ruN dgd/I3/router/include/router.h dgd-net/I3/router/include/router.h
--- dgd/I3/router/include/router.h	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/include/router.h	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,87 @@
+#ifndef ROUTER_DOT_H_INCLUDED
+#define ROUTER_DOT_H_INCLUDED
+
+#include <routercfg.h>
+
+/*
+ * debug bits
+ */
+#define DEBUG_CORE     1
+#define DEBUG_TRANSMIT 2
+#define DEBUG_DATA     4
+#define DEBUG_AUTH     8
+#define DEBUG_CHANNELS 16
+#define DEBUG_SERVICES 32
+#define DEBUG_IRN      64
+
+/*
+ * Debugging/logging macros
+ */
+#define IMUDDEBUG(L,X) if(DBL & L) log_file("router",X+"\n",LOGLEVEL_DEBUG)
+#define IMUDWARN(X)  log_file("router",X+"\n",LOGLEVEL_WARN)
+#define IMUDERROR(X) log_file("router",X+"\n",LOGLEVEL_ERROR)
+#define IMUDLOG(X)   log_file("router",X+"\n",LOGLEVEL_NOTICE)
+
+/*
+ * some filenames
+ */
+#define COMMS "/system/daemon/comms"
+#define HANDLER "/system/obj/net/I3_inb_server"
+#define DRIVER "/kernel/sys/driver"
+#define SAVEFILE "/system/save/I3-router"
+
+/*
+ * the list of services is defined here..
+ */
+#define router_services ([\
+  "startup-req-1":"rcv_startup_req",\
+  "startup-req-2":"rcv_startup_req",\
+  "startup-req-3":"rcv_startup_req",\
+  "startup-req-4":"rcv_startup_req",\
+  "mudlist-req":"rcv_mudlist_req",\
+  "shutdown":"rcv_shutdown",\
+  "channel-add":"rcv_channel_add",\
+  "channel-remove":"rcv_channel_remove",\
+  "channel-admin":"rcv_channel_admin",\
+  "chan-adminlist":"rcv_chan_adminlist",\
+  "channel-m":"rcv_channel",\
+  "channel-e":"rcv_channel",\
+  "channel-t":"rcv_channel",\
+  "channel-listen":"rcv_channel_listen",\
+  "chan-filter-reply":"rcv_chan_filter_reply",\
+  "error":"rcv_error",\
+  "irn-startup-req":"rcv_irn_startup_req",\
+  "irn-startup-reply":"rcv_irn_startup_reply",\
+  "irn-mudlist-delta":"rcv_irn_mudlist_delta",\
+  "irn-mudlist-altered":"rcv_irn_mudlist_delta",\
+  "irn-chanlist-delta":"rcv_irn_chanlist_delta",\
+  "irn-chanlist-altered":"rcv_irn_chanlist_delta",\
+  "irn-ping-req":"rcv_irn_ping",\
+  "irn-ping":"rcv_irn_ping",\
+  "irn-shutdown":"rcv_irn_shutdown",\
+])
+
+/*
+ * prototypes
+ */
+
+static void    mudlist_changed(string what, varargs int flag, int route);
+       string  *query_error_data(varargs int errno);
+       int     broadcast_mudlist_change(string what, varargs string * skip);
+static int     broadcast_packet(mixed * data, int localsrc);
+static int     multicast_packet(string * destination, mixed *data, int localsrc);
+static int     send_packet(string destination, mixed *data, int localsrc);
+static int     send_to_node(object p, mixed * data, varargs int route);
+static void    irn_broadcast_mudlist_change(string what);
+static void    notify_mud_removed(string src);
+static int     send_from_router(string ptype, mixed destmud, mixed destuser, mixed * data, varargs int route);
+       object  find_irn(string str);
+static mapping i3_nodes();
+static string  *i3_node_names();
+static object  *i3_node_objects();
+static mapping irn_nodes();
+static string  *irn_node_names();
+static object  *irn_node_objects();
+
+
+#endif
diff -ruN dgd/I3/router/lib/irnv1srv.c dgd-net/I3/router/lib/irnv1srv.c
--- dgd/I3/router/lib/irnv1srv.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/lib/irnv1srv.c	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,181 @@
+/*
+ * IRN related functionality
+ *
+ */
+
+#include <intermud3.h>
+#include <router.h>
+#include <loglevels.h>
+
+static mapping irn;
+private int DBL;
+
+static mapping query_router_list();
+static string query_mypass();
+static string query_myname();
+static int send_notice(mixed destmud, mixed destuser, mixed * data, varargs int route);
+mapping query_muddata();
+
+static void set_irn_dbl(int i) {
+  DBL = i;
+}
+
+static mapping irn_nodes() {
+  return irn;
+}
+
+static string *irn_node_names() {
+  return m_indices(irn);
+}
+
+static object *irn_node_objects() {
+  return m_values(irn);
+}
+
+void start_irn_con(string irnname) {
+  string ip;
+  int port;
+  string srvpass;
+  object con;
+  mapping rl;
+
+  rl = query_router_list();
+
+  if(rl[irnname] && !irn[irnname] && rl[irnname][3] == 1) {
+    IMUDDEBUG(DEBUG_IRN,"Trying to connect to "+(irnname ? irnname:"<NONE>"));
+    ip = rl[irnname][0];
+    port = rl[irnname][1];
+    srvpass = rl[irnname][2];
+    con = clone_object(HANDLER);
+    con->irn_outgoing(irnname,query_mypass(),srvpass,ip,port);
+  } else {
+    IMUDDEBUG(DEBUG_IRN,"Skipping "+(irnname ? irnname:"<NONE>")+", it is disabled.");
+  }
+}
+
+void stop_irn_con(string str) {
+  if(irn[str]) {
+    irn[str]->force_disconnect();
+  }
+}
+
+static void register_irn(object o, string n) {
+  if(!irn) irn = ([]);
+  o->set_nodename(n);
+  o->set_irn(1);
+  o->set_localsrc(0);
+  irn[n] = o;
+  IMUDLOG("irn node "+n+" connected from "+query_ip_number(o));
+}
+
+static int authenticate_irn(object con, mixed *data) {
+  string src,dst,ip;
+  mapping rl;
+
+  IMUDDEBUG((DEBUG_IRN | DEBUG_AUTH),"IRN authentication request from "+query_ip_number(con));
+  if(sizeof(data) < 7 || !mappingp(data[6])) return ERROR_BAD_PACKET;
+  src = (data[2] ? data[2]:nil);
+  dst = (data[4] ? data[4]:nil);
+  IMUDDEBUG((DEBUG_IRN | DEBUG_AUTH),"Claims to be "+(src ? src:"<NO NAME>"));
+  if(!src) {
+    return ERROR_BAD_SOURCE;
+  }
+
+  if(dst != query_myname()) {
+    IMUDDEBUG((DEBUG_IRN | DEBUG_AUTH),"bad destination for auth packet: "+dst);
+    return ERROR_INVALID_DESTINATION;
+  }
+
+  rl = query_router_list();
+
+  if(!rl[src]) {
+    IMUDDEBUG((DEBUG_IRN | DEBUG_AUTH),"Unknown router: "+src);
+    return ERROR_PERMISSION_DENIED;
+  }
+
+  ip = query_ip_number(con);
+  if(rl[src][0] != ip) {
+    IMUDDEBUG((DEBUG_IRN | DEBUG_AUTH),"Bad ip "+ip+" for "+src+", it is registered at "+rl[src][0]);
+    return ERROR_PERMISSION_DENIED;
+  }
+  if(data[6]["server_password"] != query_mypass() ||
+     data[6]["client_password"] != rl[src][2]
+  ) {
+    IMUDDEBUG((DEBUG_IRN | DEBUG_AUTH),"Bad password for "+src);
+    return ERROR_PERMISSION_DENIED;
+  }
+
+  /*
+   * Allow replacing dead connections
+   * Also, discard spurious registation attempts.
+   */
+  if(irn[src] && irn[src] != con) {
+    IMUDDEBUG(DEBUG_IRN,"Forcing disconnect of other session: "+object_name(irn[src]));
+    irn[src]->force_disconnect();
+  }
+  if(!irn[src]) register_irn(con,src);
+}
+
+object find_irn(string str) {
+  return irn[str];
+}
+
+int register_outbound_irn() {
+  object con;
+  string src;
+
+  con = (object HANDLER) previous_object();
+  if(!con) return 0;
+
+  src = con->query_nodename();
+  /*
+   * If there already exists a connection to the claimed name,
+   * refuse to register
+   */
+  if(find_irn(src)) {
+    return 0;
+  } else {
+    register_irn(con,src);
+    call_out("send_irn_mudlist",0,src);
+    return 1;
+  }
+}
+
+static void irn_reconnect() {
+  int i;
+  string *nodes;
+  string myname;
+
+  myname = query_myname();
+
+  nodes = m_indices(query_router_list());
+  for(i=0;i<sizeof(nodes);i++) {
+    if(nodes[i] != myname && !irn[nodes[i]]) {
+      start_irn_con(nodes[i]);
+    } else if((nodes[i] != myname) && irn[nodes[i]] && (time() - irn[nodes[i]]->query_lastread() >= 120)) {
+      stop_irn_con(nodes[i]);
+    } else if((nodes[i] != myname) && irn[nodes[i]] && (time() - irn[nodes[i]]->query_lastsent() >= 60)) {
+      send_to_node(irn[nodes[i]],({"irn-ping",5,myname,0,nodes[i],0,time(),time()}));
+    }
+  }
+}
+
+void notify_irn_disconnect() {
+  string routername;
+  string *irnmuds;
+
+  if(!(object HANDLER) previous_object()) {
+    error("Illegal call to notify_irn_disconnect()");
+  }
+
+  routername = previous_object()->query_nodename();
+  if(routername) {
+    IMUDWARN("Router "+routername+" disconnected.");
+    irn[routername]=nil;
+    irnmuds = m_indices(query_muddata());
+    irnmuds = filter_array(irnmuds,"mark_for_router_down",this_object(),routername);
+    irnmuds = filter_array(irnmuds,"queue_mudlist_changed",this_object());
+    send_notice(({"Way of the Force","The Zone","WOTF Devel"}),0,({"Router "+routername+" disconnected."}),1);
+  }
+}
+
diff -ruN dgd/I3/router/lib/mudlist.c dgd-net/I3/router/lib/mudlist.c
--- dgd/I3/router/lib/mudlist.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/lib/mudlist.c	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,532 @@
+# include <config.h>
+# include <limits.h>
+# include <intermud3.h>
+# include <pathnames.h>
+# include <loglevels.h>
+
+#define PUBLIC_FIELD_NAME ({"old_mudlistid","old_chanlistid","telnet port","I3 TCP","I3 UDP","mudlib","base mudlib","driver","type","open","admin email","services","other data"})
+
+
+private inherit "/kernel/lib/mudos/saverestore_var";
+
+# include <router.h>
+
+int mudlistid;
+int irnmudlistid;
+
+mapping muddata;                        /* internal mudlist */
+mapping expired;                        /* expired muds, mud:changeid */
+mapping queue;                          /* hold queue for pending changes */
+
+private int DBL;
+private string myname;
+
+static mapping make_irn_mudlist_entry(string mud);
+static mixed * make_mudlist_entry(string mud);
+nomask int query_queue_time(string mud);
+static void save_me();
+
+
+static void set_mudlist_dbl(int i) {
+  DBL = i;
+}
+
+static void set_myname(string str) {
+  myname = str;
+}
+
+static void create() {
+  string * muds;
+  int i;
+
+  if(!muddata) muddata = ([]);
+  if(!expired) expired = ([]);
+  if(!queue) queue = ([]);
+
+  muds = m_indices(muddata);
+  for(i=0;i<sizeof(muds);i++) {
+    muddata[muds[i]]["delay"] = 0;
+  }
+}
+
+static void destroying() {
+  string * muds;
+  int i;
+
+  muds = m_indices(muddata);
+
+  for(i=0;i<sizeof(muds);i++) {
+    muddata[muds[i]]["delay"] = 0;
+  }
+}
+
+/*
+ * Find all muds that expired since the given mudlistid
+ */
+nomask static int filter_expired(string mud, int oldid) {
+  return expired[mud] && oldid < expired[mud];
+}
+
+nomask static string * expired_since(int oldid) {
+  return filter_array(m_indices(expired),"filter_expired",this_object(),oldid);
+}
+
+/*
+ * Send a mudlist change concerning mud 'mud' to i3 node 'destination'
+ * Note that this always uses i3v4 packets, the connection object
+ * will take care of downgrading them to v3 packets when needed.
+ */
+nomask static int send_mudlist_delta(string mud,string destination) {
+  IMUDDEBUG(DEBUG_SERVICES,"Sending mudlist entry for "+mud+" to "+destination);
+  if(muddata[mud]) {
+    send_from_router(
+      "mudlist-delta",
+      destination,
+      0,
+      ({
+        mudlistid,
+        mud,
+        ({ 
+          query_queue_time(mud) ? -1:muddata[mud]["delay"],
+          muddata[mud]["lastip"]
+        }) + make_mudlist_entry(mud)
+      })
+    );
+  } else {
+    send_from_router( "mudlist-delta", destination, 0, ({ mudlistid, mud, 0 }) );
+  }
+}
+
+/*
+ * Send a irn-mudlist-delta packet concerning mud 'mud' to irn router 'destination'
+ */
+nomask static int send_irn_mudlist_delta(string mud,string destination) {
+  if(muddata[mud]) {
+    if(muddata[mud]["router"] == myname) {
+      IMUDDEBUG((DEBUG_IRN | DEBUG_SERVICES),"Sending irn mudlist delta (add/change) for "+mud+" to "+destination);
+      send_to_node(find_irn(destination),
+        ({
+          "irn-mudlist-delta",
+          5,
+          myname,
+          0,
+          destination,
+          0,
+         irnmudlistid,
+          make_irn_mudlist_entry(mud),
+        })
+      );
+    }
+  } else {
+    IMUDDEBUG((DEBUG_IRN | DEBUG_SERVICES),"Sending irn mudlist delta (removal) for "+mud+" to "+destination);
+    send_to_node(find_irn(destination), ({
+      "irn-mudlist-delta",
+      5,
+      myname,
+      0,
+      destination,
+      0,
+      irnmudlistid,
+      ([mud:0])
+    }) );
+  }
+}
+
+/*
+ * Send a change to our muddata to all connected i3 nodes
+ */
+nomask static int broadcast_mudlist_change(string changed, varargs string * skip) {
+  string * targets;
+  int i;
+
+  targets = i3_node_names();
+  IMUDDEBUG(DEBUG_SERVICES,sprintf("targets for mudlist delta: %y",targets));
+  if(skip) {
+    targets -= skip;
+    IMUDDEBUG(DEBUG_SERVICES,sprintf("targets after removal of skip array: %y",targets));
+  }
+  for(i=0;i<sizeof(targets);i++) {
+    send_mudlist_delta(changed,targets[i]);
+  }
+}
+
+/*
+ * Send a chane to our muddata to all connected irn nodes
+ */
+nomask static void irn_broadcast_mudlist_change(string what) {
+  int i;
+  string * irnodes;
+  mapping stuff;
+  IMUDDEBUG(DEBUG_IRN | DEBUG_SERVICES, "broadcasting irn mudlist delta concerning "+what);
+  stuff = make_irn_mudlist_entry(what);
+  irnodes = irn_node_names();
+  for(i=0;i<sizeof(irnodes);i++) {
+    send_to_node(find_irn(irnodes[i]), ({"irn-mudlist-delta",5,myname,0,irnodes[i],0,irnmudlistid, stuff }) );
+  }
+}
+
+/*
+ * Send a complete mudlist (or all changes since oldid) to an i3 node.
+ */
+nomask int send_mudlist(string destination, varargs int oldid) {
+  string * muds;
+  int i;
+  mapping result;
+
+  muds = m_indices(muddata);
+
+  IMUDDEBUG(DEBUG_SERVICES,"Generating mudlist for "+destination+" ("+(oldid ? oldid:0)+")");
+#if 1
+
+  for(i=0;i<sizeof(muds);i++) {
+    if(!muddata[muds[i]]["changeid"] || muddata[muds[i]]["changeid"] > oldid) {
+      send_mudlist_delta(muds[i],destination);
+    }
+  }
+
+  if(oldid) {
+    muds = expired_since(oldid);
+    for(i=0;i<sizeof(muds);i++) {
+      send_mudlist_delta(muds[i],destination);
+    }
+  }
+#else
+  result = ([]);
+  for(i=0;i<sizeof(muds);i++) {
+    if(!muddata[muds[i]]["changeid"] || muddata[muds[i]]["changeid"] > oldid) {
+      result[muds[i]] = ({ 
+        query_queue_time(muds[i]) ? -1:muddata[muds[i]]["delay"],
+        muddata[muds[i]]["lastip"] 
+      })+make_mudlist_entry(muds[i]);
+    }
+  }
+  if(oldid) {
+    muds = expired_since(oldid);
+    for(i=0;i<sizeof(muds);i++) {
+      result[muds[i]] = 0;
+    }
+  }
+  IMUDDEBUG(DEBUG_SERVICES,(m_sizeof(result) ? sprintf("Sending mudlist data for %y\n",m_indices(result)):"No data to be sent\n"));
+  return send_from_router( "mudlist-reply", destination, 0, ({ mudlistid, result }) );
+#endif
+}
+
+/*
+ * Send a complete irn mudlist to irn node 'destination'
+ */
+nomask static void send_irn_mudlist(string destination) {
+  int i;
+  string * mudnames;
+
+  mudnames = m_indices(muddata);
+  for(i=0;i<sizeof(mudnames);i++) {
+    send_irn_mudlist_delta(mudnames[i],destination);
+  }
+}
+
+/*
+ * Our internal muddata has changed, inform the world as appropriate
+ */
+nomask static void mudlist_changed(string what, varargs int flag, int route) {
+  mudlistid++;
+  if(muddata[what]) {
+    if(expired[what]) expired[what] = nil;
+    muddata[what]["changeid"] = mudlistid;
+    IMUDDEBUG(DEBUG_SERVICES,"Changeid for "+what+" is "+mudlistid);
+  } else {
+    expired[what] = mudlistid;
+    IMUDDEBUG(DEBUG_SERVICES,"Added "+what+" to expired list with changeid "+mudlistid);
+  }
+
+  if(flag) {
+    broadcast_mudlist_change(what,({what}));
+  } else {
+    broadcast_mudlist_change(what);
+  }
+  if(route) {
+    irnmudlistid++;
+    irn_broadcast_mudlist_change(what);
+  }
+  save_me();
+}
+
+/*
+ * queue a change to the mudlist (to be processed in 5 mins if not changed
+ */
+nomask static void queue_mudlist_changed(string mud) {
+  IMUDDEBUG(DEBUG_SERVICES,"queueing mudlist change for "+mud);
+  queue[mud] = time()+300;
+}
+
+/*
+ * expiration time for delayed mudlist change
+ */
+nomask int query_queue_time(string mud) {
+  return queue[mud] != nil ? queue[mud]:0;
+}
+
+/*
+ * remove delayed change from queue
+ */
+nomask void dequeue_mudlist_changed(string mud) {
+  IMUDDEBUG(DEBUG_SERVICES,"dequeueing mudlist change for "+mud);
+  queue[mud] = nil;
+}
+
+/*
+ * Check the queue
+ */
+nomask void run_queue() {
+  int i;
+  string *muds;
+
+  IMUDDEBUG(DEBUG_CORE,"running queue");
+  muds = m_indices(queue);
+  for(i=0;i<sizeof(muds);i++) {
+    if(queue[muds[i]] < time()) {
+      IMUDDEBUG(DEBUG_SERVICES,"Delayed mudlist delta concerning "+muds[i]);
+      queue[muds[i]] = nil;
+      mudlist_changed(muds[i],0,0);
+    }
+  }
+}
+  
+/*
+ * Return muddata in i3 mudlist format
+ */
+nomask static mixed * make_mudlist_entry(string mud) {
+  if(muddata[mud]) {
+    return muddata[mud]["public"][2..];
+  }
+}
+
+/*
+ * Return muddata in irn mudlist format
+ */
+nomask static mapping make_irn_mudlist_entry(string mud) {
+  mapping data;
+
+  if(!mud) error("make_irn_mudlist_entry NEEDS an argument!");
+  if(!muddata[mud]) {
+    return ([mud:0]);
+  } else if( !mappingp(muddata[mud]) ) {
+    error("muddata["+mud+"] is NOT a mapping! "+typeof(muddata[mud]));
+  }
+
+  data = muddata[mud];
+  if(!data) {
+    return ([mud:0]);
+  } else {
+    if(sizeof(data["public"]) == 11) {
+      if(data["version"] != 1) {
+        IMUDWARN("public data in v1 format but mud claims some other version: "+data["version"]);
+      }
+      data["public"] = data["public"][..9]+({""})+data["public"][10..]+({0});
+    }
+    return ([mud:
+      (["old_mudlist_id":data["public"][0],
+        "old_chanlist_id":data["public"][1],
+        "player_port":data["public"][2],
+        "imud_tcp_port":data["public"][3],
+        "imud_udp_port":data["public"][4],
+        "mudlib":data["public"][5],
+        "base_mudlib":data["public"][6],
+        "driver":data["public"][7],
+        "mud_type":data["public"][8],
+        "open_status":data["public"][9],
+        "admin_email":data["public"][10],
+        "services":data["public"][11],
+        "other_data":data["public"][12],
+        "password":data["password"],
+        "connect_time":data["connect_time"],
+        "disconnect_time":data["disconnect_time"],
+        "name":mud,
+        "ip":data["lastip"],
+        "version":data["version"],
+        "restart_delay":data["delay"],
+        "router":data["router"]
+      ])
+    ]);
+  }
+}
+
+nomask static void store_muddata(string mud, mapping md) {
+  int pub,delay,i;
+
+  pub = 0;
+  delay = 0;
+
+  if(!muddata[mud]) {
+    IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"No muddata on "+mud);
+    pub++;
+  } else {
+    if(sizeof(md["public"]) == 11) {
+      IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"v1 mudlist data for "+mud);
+      md["public"] = md["public"][0..9] + ({""})+md["public"][10..] + ({0});
+    }
+    for(i=0;i<sizeof(md["public"]);i++) {
+      if(md["public"][i] == nil) {
+        /* no nils in i3 data allowed */
+        md["public"][i] = 0;
+      }
+      /* did anything change in the public part of the mud data? */
+      if(i >= 2) {
+        if(i>=sizeof(muddata[mud]["public"])) {
+          IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"Field "+i+" missing in muddata[\""+mud+"\"][\"public\"]");
+          pub++;
+        } else if(typeof(md["public"][i]) != typeof(muddata[mud]["public"][i]) ||
+          ((intp(md["public"][i]) || stringp(md["public"][i])) && md["public"][i] != muddata[mud]["public"][i]) ||
+          ((mappingp(md["public"][i]) || arrayp(md["public"][i])) && save_variable(md["public"][i]) != save_variable(muddata[mud]["public"][i]))
+        ) {
+          IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"public change ("+(PUBLIC_FIELD_NAME[i]? PUBLIC_FIELD_NAME[i]:"unknown field "+i)+")");
+          pub++;
+        }
+      }
+    }
+
+    if(md["lastip"] != muddata[mud]["lastip"]) {
+      IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"public change (ip)");
+      pub++;
+    }
+
+    if(query_queue_time(mud)) {
+      if(md["delay"] != -1 && md["delay"] != muddata[mud]["delay"]) {
+        IMUDDEBUG(DEBUG_SERVICES,sprintf("public change (delay was %d)",muddata[mud]["delay"]));
+        IMUDDEBUG(DEBUG_SERVICES,sprintf("public change (delay is now %d)",md["delay"]));
+        pub++;
+        if(md["delay"] < 300) {
+          delay++;
+        }
+      } else {
+        if(md["delay"] != -1) {
+          IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"Mud not online, need to send a notification to local muds");
+          pub++;
+          if(md["delay"] == muddata[mud]["delay"]) {
+            IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"If this is the only change, requeue the notification");
+            delay++;
+          } else {
+            IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"Notify inmediately if something changed");
+          }
+        } else {
+          IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"Mud back online, if nothing else changed, just dequeue");
+        }
+      }
+      dequeue_mudlist_changed(mud);
+    } else if(md["delay"] != muddata[mud]["delay"]) {
+      /*
+       * we got a different restart_delay, check if the mud is down but
+       * supposed to return soonish
+       */
+      if(muddata[mud]["delay"] == -1 && md["delay"] < 300) {
+        IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"public change (short offline)");
+        delay++;
+      } else if(muddata[mud]["delay"] >= 0 && md["delay"] == -1) {
+        IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"public change (online)");
+      } else if(muddata[mud]["delay"] == -1) {
+        IMUDDEBUG(DEBUG_SERVICES|DEBUG_IRN,"public change (long offline)");
+      }
+      pub++;
+    }
+  }
+
+  muddata[mud] = md;
+
+  if(pub == 1 && delay == 1) {
+    queue_mudlist_changed(mud);
+  } else if(pub) {
+    mudlist_changed(mud,0,0);
+  }
+}
+  
+/*
+ * Convert irn mudlist data to internal format and store it.
+ */
+nomask static void store_irn_muddata(mapping md) {
+  string name;
+  int i, delay, irnchange,pubchange;
+  mapping data;
+
+  name = md["name"];
+  if(!name) {
+    IMUDERROR("Call to store_irn_muddata but I can't find a mudname!\n");
+  }
+
+  IMUDDEBUG(DEBUG_SERVICES,"Storing irn mudlist data for "+name);
+
+  pubchange = 0;
+  delay = 0;
+
+  if(expired[name]) {
+    expired[name] = nil;
+  }
+
+  data = ([
+    "delay":md["restart_delay"],
+    "router":md["router"],
+    "connect_time":md["connect_time"],
+    "disconnect_time":md["disconnect_time"],
+    "version":md["version"],
+    "lastip":md["ip"],
+    "password":md["password"],
+    "public":({ 
+      md["old_mudlist_id"],
+      md["old_chanlist_id"],
+      md["player_port"],
+      md["imud_tcp_port"],
+      md["imud_udp_port"],
+      md["mudlib"],
+      md["base_mudlib"],
+      md["driver"],
+      md["mud_type"],
+      md["open_status"],
+      md["admin_email"],
+      md["services"],
+      md["other_data"]
+    })
+  ]);
+  store_muddata(name,data);
+}
+
+/*
+ * Cleanup the mudlist
+ */
+void remove_mud(string str) {
+  
+  if(query_queue_time(str)) dequeue_mudlist_changed(str);
+  muddata[str] = nil;
+  mudlist_changed(str,0,1);
+}
+
+nomask static void do_cleanup() {
+  int i;
+  string * oldlist;
+  oldlist = m_indices(muddata) + ({});
+  muddata = filter_mapping(muddata,"filter_muddata",this_object());
+  for(i=0;i<sizeof(oldlist);i++) {
+    if(!muddata[oldlist[i]]) {
+      IMUDLOG("Removed "+oldlist[i]+" from mudlist.");
+      broadcast_mudlist_change(oldlist[i]);
+      notify_mud_removed(oldlist[i]);
+    }
+  }
+}
+
+nomask mapping get_muddata(string mud) {
+  return muddata[mud] ? muddata[mud][..] : nil;
+}
+
+nomask void fix_offline() {
+  string * muds;
+  int i;
+
+  muds = m_indices(muddata);
+  for(i=0;i<sizeof(muds);i++) {
+    if(muddata[muds[i]]["delay"] == -1 && muddata[muds[i]]["connect_time"] == 0) {
+      IMUDWARN("Fixed restart_delay for "+muds[i]);
+      muddata[muds[i]]["delay"] = 0;
+      mudlist_changed(muds[i]);
+    }
+  }
+}
+
+ 
diff -ruN dgd/I3/router/obj/I3_inb_server.c dgd-net/I3/router/obj/I3_inb_server.c
--- dgd/I3/router/obj/I3_inb_server.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/router/obj/I3_inb_server.c	2008-10-31 13:26:13.000000000 +0100
@@ -0,0 +1,296 @@
+/*
+  I3 inband server object
+  This should be used together with an I3 router object
+
+  This provides a connection for a single mud.
+*/
+
+#ifdef status
+#undef status
+#endif
+
+#include <config.h>
+#include <status.h>
+#include <limits.h>
+#include <routercfg.h>
+#include <intermud3.h>
+#include <loglevels.h>
+
+#define DBT(X) if(find_player("aidil")) find_player("aidil")->tell(X+"\n")
+#define ROUTER "/system/daemon/net/I3_router"
+
+
+inherit "/system/lib/net/services";
+inherit "/kernel/lib/net/netobj";
+inherit "/lib/timefuns";
+
+static int connected, closing, down, lastsent, lastread, pktsent, pktread;
+static int trace_protocol;
+string netname;
+static mixed * packets;
+static mapping services;
+static int protocol_version;
+static int localsrc;
+static int irn;
+
+void set_protocol_version(int v) {
+  protocol_version = v;
+}
+
+int query_protocol_version() {
+  return protocol_version;
+}
+
+void set_services(mapping s) {
+  if(mappingp(s)) {
+    services = s + ([]);
+  }
+}
+
+mapping query_services() {
+  return services ? services + ([]) : ([]);
+}
+
+#ifdef I3_UCACHE_FILTERING
+int test_service_available(string service) {
+  if(irn) return 1;
+  switch(service) {
+    case "ucache-update" : 
+                             return services && services["ucache"];
+                             break;
+    case "router-shutdown" : 
+                             return (protocol_version == 4);
+                             break;
+    default                : 
+                             return 1;
+                             break;
+  }
+}
+#else
+int test_service_available(string service) {
+  IMUDLOG("huh?");
+  return 1 || (services && services[service] == 1);
+}
+#endif
+
+void set_nodename(string str) {
+  connected = 1;
+  netname = str;
+}
+
+string query_nodename() {
+  return netname;
+}
+
+int query_trace_protocol() { return trace_protocol; }
+void set_trace_protocol(int i) { trace_protocol = (i != 0); }
+
+void IMUDLOG( string str ) {
+  log_file( "router","("+netname+") : " + str ,LOGLEVEL_NOTICE);
+}
+
+void IMUDERROR(string str) {
+  log_file( "router", "("+netname+") : "+str, LOGLEVEL_ERROR);
+}
+
+void TRACEIN(mixed data) {
+  if(trace_protocol) {
+    write_file("/log/admin/intermud3_trace",
+      "<< "+ctime(time())+"\n"+
+      sprintf("%y\n",data)
+    );
+  }
+}
+
+void TRACEOUT(mixed data) {
+  if(trace_protocol) {
+    write_file("/log/admin/intermud3_trace",
+      ">> "+ctime(time())+"\n"+
+      sprintf("%y\n",data)
+    );
+  }
+}
+
+static void send_loop() {
+  if(packets && sizeof(packets)) {
+    mixed packet;
+    packet = packets[0];
+    if(sizeof(packets) > 1) {
+      packets = packets[1..];
+      call_out("send_loop",0);
+    } else {
+      packets = ({});
+    }
+    pktsent++;
+    lastsent = time();
+    send_message(packet);
+  }
+}
+
+mixed * mangle_incoming_packet(mixed * data) {
+  switch(data[0]) {
+    case "startup-req" : log_file("router","translating startup-req\n",LOGLEVEL_DEBUG);
+    case "startup-req-1" : log_file("router","version 1\n",LOGLEVEL_DEBUG);
+      data = data[0..16]+({""})+data[17..]+({0});
+      data[0] = "startup-req-1";
+  }
+  return data;
+}
+    
+/* 
+ * translate outgoing packets for the target mud if needed.
+ */
+mixed * mangle_outgoing_packet(mixed * data) {
+  mixed * result;
+  if(protocol_version == 0 || protocol_version == 4) {
+    result = data;
+  } else {
+    switch(data[0]) {
+      case "mudlist-reply" :
+        result = ({"mudlist"})+data[1..];
+        break;
+      case "mudlist-delta" :
+        result = ({"mudlist",5})+data[2..6]+({([data[7]:data[8]])});
+        break;
+      case "chanlist-delta" :
+        result = ({"chanlist-reply",5})+data[2..6]+({([data[7]:data[8]])});
+        break;
+      default :
+        result = data;
+        break;
+    }
+  }
+  if(protocol_version == 1 && result[0] == "mudlist") {
+    int i,j;
+    mixed mud;
+    string *muds;
+    muds = m_indices(result[7]);
+    for(i=0;i<sizeof(muds);i++) {
+      mud = result[7][muds[i]];
+      if(arrayp(mud)) {
+        mud = mud[0..9] + mud[11..11];
+        result[7][muds[i]] = mud;
+      }
+    }
+  }  
+  return result;
+}
+
+public int receive_router_data(mixed * data) {
+  if(!packets) packets = ({});
+  if(data) {
+    data = mangle_outgoing_packet(data);
+    packets += ({ data });
+    if(find_call_out("send_loop") == -1) {
+      call_out("send_loop",0);
+    }
+  }
+}
+
+
+static void send_router_data(mixed data) {
+  pktread++;
+  lastread = time();
+  data = mangle_incoming_packet(data);
+  ROUTER->route_packet(data);
+}
+
+void receive_message(mixed data) {
+  if(data && pointerp(data)) send_router_data(data);
+  else if(data) IMUDERROR(sprintf("%y",data));
+}
+
+void close() {
+  if(closing) return;
+  closing = 1;
+  if(previous_object() != _Q_connection() && previous_object() != this_object()) return;
+  catch(remove_call_out("timeout_connection"));
+  catch(destruct(this_object()));
+}
+
+void timeout_connection() {
+  if(connected) return;
+  if(catch(close_user())) {
+    close();
+  }
+}
+
+static int outgoing;
+static string mypass;
+static string theirpass;
+
+void irn_outgoing(string iname, string myp, string theirp, string ip, int port) {
+  set_nodename(iname);
+  mypass = myp;
+  theirpass = theirp;
+  outgoing = 1;
+  connect(ip,port,"mudmode");
+}
+
+void open()
+{
+  if(outgoing) {
+    receive_router_data(
+      ({"irn-startup-req",
+        5,
+        ROUTER->query_nodename(),
+        0,
+        query_nodename(),
+        0,
+        (["client_password":mypass,
+          "server_password":theirpass
+        ])
+      })
+    );
+    if(ROUTER->register_outbound_irn()) {
+      connected = 1;
+    } else {
+      call_out("timeout_connection",0);
+    }
+  }
+}
+
+void destroying() {
+  catch(close_user());
+  if(irn) catch(ROUTER->notify_irn_disconnect());
+  else catch(ROUTER->notify_disconnect());
+}
+
+void create() {
+  if(!original()) {
+    call_out("timeout_connection",120);
+    packets = ({});
+  }
+}
+
+void force_disconnect() {
+  if(previous_object() == get_object(ROUTER)) {
+    if(!closing) {
+      closing = 1;
+      catch(destruct_object(this_object()));
+    }
+  }
+}
+
+void set_localsrc(int flag) {
+  localsrc = flag ? 1:0;
+}
+
+void set_irn(int flag) {
+  irn = flag ? 1:0;
+}
+
+int query_localsrc() { return localsrc; }
+int query_irn() { return irn; }
+
+void upgraded() {
+  if(!original() && !connected) {
+    call_out("timeout_connection",10);
+  }
+}
+
+int query_pktsent() { return pktsent; }
+int query_pktread() { return pktread; }
+int query_lastsent() { return lastsent; }
+int query_lastread() { return lastread; }
+
diff -ruN dgd/I3/saverestore_var.c dgd-net/I3/saverestore_var.c
--- dgd/I3/saverestore_var.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/I3/saverestore_var.c	2008-10-31 12:12:54.000000000 +0100
@@ -0,0 +1,254 @@
+/*
+ * saverestore_var.c
+ *
+ * Emulates the MudOS save_variable and restore_variable efunctions.
+ *
+ * 8 January 1997       Begun           Greg Lewis
+ *      # Wrote and tested initial version.  restore_variable needs to do
+ *        error checking though (i.e., it works if the string it gets is
+ *        right, but crashes and burns otherwise ;).
+ *
+ * 10 January 1997      Version 1.0     Greg Lewis
+ *      # Added error checking to restore_variable, it returns RESTORE_ERROR
+ *        upon errors in the restore process.
+ *      # Everything seems to test ok, not that I've been all that thorough.
+ *
+ * TBD
+ *      # Prolly needs some more commenting (doesn't most code?)
+ *
+ *  October 2008         Version 2.0     Bart van Leeuwen
+ *      # Completely rewrote restore_variable()
+ *      # It no longer returns RESTORE_ERROR upon errors, rather it returns
+ *        nil. There are no other cases in which nil can be returned, this
+ *        results in much better error detection (RESTORE_ERROR could also
+ *        be a valid restore of an int that happens to contain that value)
+ *      # objectids are not restored, at best they make no sense over a
+ *        mudmode connection, at worst they are a security problem.
+ */
+
+#include <type.h>
+
+#define GRAMMAR \
+  "escaped=/\\\\/\n"+\
+  "quote=/\"/\n"+\
+  "floats=/[\-]?[0-9]*[.][0-9]+/\n"+\
+  "arraystart=/[(][{][ ]*/\n"+\
+  "arrayend=/[ ]*[}][)]/\n"+\
+  "arraysep=/[ ]*,[ ]*/\n"+\
+  "mapstart=/[(][[][ ]*/\n"+\
+  "mapend=/[ ]*][)]/\n"+\
+  "mapsep=/[ ]*:[ ]*/\n"+\
+  "ints=/[\-]?[0-9]+/\n"+\
+  "char=/./\n"+\
+  "var: float\n"+\
+  "var: int\n"+\
+  "var: string\n"+\
+  "var: array\n"+\
+  "var: map\n"+\
+  "string: quote quote ? emptystring\n"+\
+  "string: quote chars quote ? concatstring\n"+\
+  "array: arraystart arrayend ? mkemptyarray\n"+\
+  "array: arraystart arrayelements arrayend ? mkarray\n"+\
+  "map: mapstart mapend ? mkemptymap\n"+\
+  "map: mapstart mapelements mapend ? mkmap\n"+\
+  "arrayelements: element\n"+\
+  "arrayelements: arrayelements arraysep element\n"+\
+  "arrayelements: arrayelements arraysep\n"+\
+  "element: int\n"+\
+  "element: float\n"+\
+  "element: string\n"+\
+  "element: array\n"+\
+  "element: map\n"+\
+  "mapelements: element mapsep element\n"+\
+  "mapelements: mapelements arraysep element mapsep element\n"+\
+  "mapelements: mapelements arraysep\n"+\
+  "chars: char\n"+\
+  "chars: escaped escaped\n"+\
+  "chars: escaped quote\n"+\
+  "chars: arraystart\n"+\
+  "chars: arrayend\n"+\
+  "chars: mapstart\n"+\
+  "chars: mapend\n"+\
+  "chars: arraysep\n"+\
+  "chars: mapsep\n"+\
+  "chars: floats\n"+\
+  "chars: ints\n"+\
+  "chars: chars char\n"+\
+  "chars: chars escaped escaped\n"+\
+  "chars: chars escaped quote\n"+\
+  "chars: chars arraystart\n"+\
+  "chars: chars arrayend\n"+\
+  "chars: chars mapstart\n"+\
+  "chars: chars mapend\n"+\
+  "chars: chars arraysep\n"+\
+  "chars: chars mapsep\n"+\
+  "chars: chars floats\n"+\
+  "chars: chars ints\n"+\
+  "int: ints ? cnvint\n"+\
+  "float: floats ? cnvfloat\n"
+
+int * cnvint(mixed * data) {
+  int r;
+
+  sscanf(data[0],"%d",r);
+  return ({ r });
+}
+
+float * cnvfloat(mixed * data) {
+  float r;
+
+  sscanf(data[0],"%f",r);
+  return ({ r });
+}
+
+object * cnvobj(mixed * data) {
+  string n;
+  int i;
+
+  n = "";
+  for(i=0;i<sizeof(data[0]);i++) {
+    n += data[0][i];
+  }
+  return ({ find_object(n) });
+}
+
+string * emptystring(mixed * data) {
+  return ({ "" });
+}
+
+string * concatstring(mixed * data) {
+  int i;
+
+  string r;
+  r = "";
+
+  for(i=0;i<sizeof(data);i++) {
+    if(data[i] == "\\") i++;
+    r += data[i];
+  }
+
+  r = implode(explode(r,"\\\""),"\"");
+  r = implode(explode(r,"\\\\"),"\\");
+  return ({ r[1..strlen(r)-2] });
+}
+
+mixed * mkemptyarray(mixed * data) {
+  return ({ ({ }) });
+}
+
+mixed * mkarray(mixed * data) {
+  int i;
+  mixed * stuff;
+  stuff = ({ });
+  for(i=1; i<sizeof(data) && data[i] != "})"; i += 2) {
+    stuff += ({ data[i] });
+  }
+  return ({ stuff });
+}
+
+mixed * mkemptymap(mixed * data) {
+  return ({ ([ ]) });
+}
+
+mixed * mkmap(mixed * data) {
+  int i;
+  mapping stuff;
+  mixed key,val;
+
+  stuff = ([ ]);
+  for(i=1; i<sizeof(data) && data[i] != "])"; i += 4) {
+    key = data[i];
+    val = data[i+2];
+    stuff[key] = val;
+  }
+  return ({ stuff });
+}
+
+mixed parse_me(string str) {
+  return parse_string(GRAMMAR,str);
+}
+
+mixed restore_variable(string str) {
+  mixed * result;
+
+  result = parse_me(str);
+
+  if(!result || sizeof(result) < 1) {
+    return nil;
+  } else {
+    return result[0];
+  }
+}
+
+string save_variable(mixed var) {
+   string       result;
+   int          i, s;
+   mixed        *keys, *values;
+   string pref,post;
+
+   if (!var) {
+      return "0";
+   }
+   switch (_typeof(var)) {
+      case T_INT : case T_FLOAT :
+         result = ""+var;
+         break;
+      case T_STRING :
+
+         if(strlen(var) > 0) {
+           if(var[0..0] == "\\") {
+             pref = "\\\\";
+           } else if(var[0..0] == "\"") {
+             pref = "\\\"";
+           } else {
+             pref = "";
+           }
+
+           if(var[strlen(var)-1] == '\\') {
+             post = "\\\\";
+           } else if(var[strlen(var)-1] == '\"') {
+             post = "\\\"";
+           } else {
+             post = "";
+           }
+
+           result = implode(explode(var, "\\"), "\\\\");
+           result = implode(explode(result, "\""), "\\\"");
+           result = "\""+pref+result+post+"\"";
+         } else {
+           result = "\"\"";
+         }
+         break;
+      case T_OBJECT :
+         result = object_name(var);
+         break;
+      case T_ARRAY :
+         result = "({";
+         for (i = 0, s = sizeof(var); i < s; i++) {
+            result += save_variable(var[i]) + ",";
+         }
+         result += "})";
+         break;
+      case T_MAPPING :
+         keys = map_indices(var);
+         values = map_values(var);
+         result = "([";
+         for (i = 0, s = map_sizeof(var); i < s; i++) {
+            result += save_variable(keys[i]) + ":" + save_variable(values[i])
+                      + ",";
+         }
+         result += "])";
+         break;
+      default :
+         result = nil;
+         break;
+   }
+   return result;
+}
+
+mixed testme() {
+  mapping q;
+
+  q = "/system/daemon/net/I3_router"->query_muddata();
+  return restore_variable(save_variable(q));
+}
diff -ruN dgd/mud/include/config.h dgd-net/mud/include/config.h
--- dgd/mud/include/config.h	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/mud/include/config.h	2008-05-19 16:14:50.000000000 +0200
@@ -6,3 +6,10 @@
 # undef SYS_PERSISTENT		/* off by default */
 
 # define CALLOUTRSRC	FALSE	/* don't have callouts as a resource */
+
+# ifdef SYS_NETWORKING
+#  define TELNET_PORT     6047    /* default telnet port */
+#  define BINARY_PORT     6048    /* default binary port */
+#  define EMERGENCY_PORT  6049    /* emergency binary port */
+# endif
+
diff -ruN dgd/mud/include/kernel/kernel.h dgd-net/mud/include/kernel/kernel.h
--- dgd/mud/include/kernel/kernel.h	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/mud/include/kernel/kernel.h	2008-05-19 16:14:50.000000000 +0200
@@ -1,4 +1,7 @@
 # include <config.h>
+# ifndef SYS_NETWORKING
+# define SYS_NETWORKING
+# endif
 
 # define DRIVER		"/kernel/sys/driver"
 # define AUTO		("/kernel" + INHERITABLE_SUBDIR + "auto")
diff -ruN dgd/mud/include/kernel/net.h dgd-net/mud/include/kernel/net.h
--- dgd/mud/include/kernel/net.h	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/mud/include/kernel/net.h	2008-05-19 16:14:50.000000000 +0200
@@ -0,0 +1,10 @@
+# ifdef SYS_NETWORKING
+#  define LIB_PORT 	"/kernel/lib/network/port"
+#  define PORT_OBJECT	"/kernel/obj/port"
+#  define PORT_TELNET   "/kernel/sys/telnet_port"
+#  define PORT_BINARY   "/kernel/sys/binary_port"
+#  define PORT_EMERGENCY "/kernel/sys/emergency_port"
+#  define PORT_UDP	"/kernel/obj/udp"
+# else
+#  error	networking capabilities required
+# endif
diff -ruN dgd/mud/include/kernel/user.h dgd-net/mud/include/kernel/user.h
--- dgd/mud/include/kernel/user.h	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/mud/include/kernel/user.h	2008-05-19 16:14:50.000000000 +0200
@@ -6,6 +6,10 @@
 # define BINARY_CONN		("/kernel" + CLONABLE_SUBDIR + "binary")
 # define API_USER		("/kernel" + INHERITABLE_SUBDIR + "api/user")
 
+#ifdef __NETWORK_PACKAGE__
+#define LIB_PORT                "/kernel/lib/network/port"
+#endif
+
 # define DEFAULT_USER		("/kernel" + CLONABLE_SUBDIR + "user")
 # define DEFAULT_WIZTOOL	("/kernel" + CLONABLE_SUBDIR + "wiztool")
 # define DEFAULT_USER_DIR	"/kernel/data"
diff -ruN dgd/mud/include/std.h dgd-net/mud/include/std.h
--- dgd/mud/include/std.h	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/mud/include/std.h	2008-05-19 16:14:50.000000000 +0200
@@ -1,2 +1,8 @@
+#ifdef __NETWORK_PACKAGE__
+#ifndef SYS_NETWORKING
+#define SYS_NETWORKING
+#endif
+#endif
+
 # define TRUE	1
 # define FALSE	0
diff -ruN dgd/mud/kernel/lib/auto.c dgd-net/mud/kernel/lib/auto.c
--- dgd/mud/kernel/lib/auto.c	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/mud/kernel/lib/auto.c	2008-05-19 16:14:50.000000000 +0200
@@ -3,6 +3,10 @@
 # include <kernel/rsrc.h>
 # include <kernel/access.h>
 # include <kernel/user.h>
+# ifdef SYS_NETWORKING
+# include <kernel/net.h>
+# endif
+
 # include <status.h>
 # include <type.h>
 # include <trace.h>
@@ -1547,3 +1551,64 @@
     } : error(TLSVAR2);
     return result;
 }
+
+# ifdef SYS_NETWORKING
+/*
+ * NAME:        connect()
+ * DESCRIPTION: open an outbound connection
+ */
+static void connect(string destination, int port,varargs string proto)
+{
+    object conn;
+    string err;
+
+    if (previous_program() == LIB_CONN) {
+        if(!proto) proto = "tcp";
+        ::connect(destination, port,proto);
+    } else {
+        CHECKARG(destination, 1, "connect");
+
+        if (creator == "System" && this_object()) {
+            if (function_object("query_conn", this_object()) != LIB_USER) {
+                error("Not a user object");
+            }
+            conn = clone_object(BINARY_CONN, "System");
+            call_other(this_object(),"connection",conn);
+            conn->connect(destination, port,proto);
+            if(err) {
+                rlimits (-1; -1) {
+                    destruct_object(conn);
+                }
+                error(err);
+            }
+        }
+    }
+}
+
+static object port_object;
+
+/*
+ * NAME:        open_port()
+ * DESCRIPTION: open a port to listen on
+ */
+static void open_port(string protocol, varargs int port)
+{
+    CHECKARG(protocol, 1, "open_port");
+
+    if (KERNEL() && this_object()) {
+        ::open_port(protocol, port);
+    }
+}
+
+/*
+ * NAME:        ports()
+ * DESCRIPTION: return list of open ports
+ */
+static object *ports()
+{
+    if (creator == "System") {
+        return ::ports();
+    }
+}
+# endif /* SYS_NETWORKING */
+
diff -ruN dgd/mud/kernel/lib/connection.c dgd-net/mud/kernel/lib/connection.c
--- dgd/mud/kernel/lib/connection.c	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/mud/kernel/lib/connection.c	2008-05-19 16:14:50.000000000 +0200
@@ -6,6 +6,7 @@
 private object user;		/* user object */
 private string conntype;	/* connection type */
 private int mode;		/* connection mode */
+private int outgoing;
 private int blocked;		/* connection blocked? */
 private string buffer;		/* buffered output string */
 
@@ -66,6 +67,11 @@
     int timeout;
     string banner;
 
+    if(outgoing) {
+       user->login("now");
+       return;
+    }
+
     banner = call_other(userd, "query_" + conntype + "_banner", port,
 			this_object());
     if (banner) {
@@ -74,7 +80,7 @@
 
     timeout = call_other(userd, "query_" + conntype + "_timeout", port,
 			 this_object());
-    if (timeout < 0) {
+    if (timeout < 0 && !outgoing) {
 	/* disconnect immediately */
 	destruct_object(this_object());
 	return;
@@ -83,6 +89,11 @@
     if (!user && timeout != 0) {
 	call_out("timeout", timeout);
     }
+# ifdef SYS_NETWORKING
+    else {
+        set_mode(user->login(nil));
+    }
+# endif
 }
 
 /*
@@ -136,7 +147,8 @@
  */
 void set_port(int num)
 {
-    if (previous_object() == userd) {
+    if(num == 0) error("port is 0\n");
+    if (previous_object() == userd || SYSTEM()) {
 	port = num;
     }
 }
@@ -194,7 +206,11 @@
 	user = call_other(userd, conntype + "_user", port, str);
 	set_mode(mode = user->login(str));
     } else {
-	set_mode(mode = user->receive_message(str));
+        mixed m;
+        m = user->receive_message(str);
+        if(m) mode = m;
+        else mode = 0;
+	set_mode(mode);
     }
     return mode;
 }
@@ -223,6 +239,8 @@
 		return TRUE;
 	    }
 	}
+    } else {
+        error(object_name(previous_object())+" is not allowed to do that");
     }
 }
 
@@ -240,6 +258,7 @@
     }
 }
 
+#ifndef SYS_NETWORKING
 /*
  * NAME:	datagram_challenge()
  * DESCRIPTION:	set the challenge for the datagram channel
@@ -283,3 +302,23 @@
 	return (send_datagram(str) == strlen(str));
     }
 }
+#else
+/*
+ * NAME:        connect()
+ * DESCRIPTION: establish an outbount connection
+ */
+void connect(string destination, int n,varargs string protocol)
+{
+    if (previous_program() == AUTO || previous_program() == LIB_USER) {
+        outgoing = 1;
+        user = previous_object();
+        port = n;
+        ::connect(destination, n, protocol);
+    }
+}
+
+void receive_error(string str) {
+    DRIVER->message("NETWORK ERROR: "+str+"\n");
+}
+# endif
+
diff -ruN dgd/mud/kernel/lib/network/port.c dgd-net/mud/kernel/lib/network/port.c
--- dgd/mud/kernel/lib/network/port.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/mud/kernel/lib/network/port.c	2008-05-19 16:14:50.000000000 +0200
@@ -0,0 +1,68 @@
+# include <kernel/kernel.h>
+# include <kernel/user.h>
+# include <trace.h>
+# include <type.h>
+
+private object driver;		/* driver object */
+private object userd;		/* user manager object */
+private string protocol;        /* telnet, tcp or udp */
+
+/*
+ * NAME:	create()
+ * DESCRIPTION:	initialize port object
+ */
+static void create()
+{
+    driver = find_object(DRIVER);
+    userd = find_object(USERD);
+}
+
+/*
+ * NAME:	open_port()
+ * DESCRIPTION:	start listening on a port
+ */
+static 
+void open_port(string prot, varargs int port)
+{
+    rlimits (-1; -1) {
+/*	catch {*/
+	if (typeof(port)==T_INT && port !=0) {
+		::open_port(prot, port);
+	    } else {
+		::open_port(prot);
+	    }
+	    protocol = prot;
+	    return;
+/*	} : {
+	    error(::call_trace()[1][TRACE_FIRSTARG][1]);
+	    return;
+	    }*/
+    }
+}
+
+object
+connection(mixed *tls, string ip, int port)
+{
+    object conn;
+
+    switch(protocol) {
+      case "telnet" : conn = clone_object(TELNET_CONN);
+                      break;
+      default       : conn = clone_object(BINARY_CONN);
+                      break;
+    }
+    conn->set_port(port);
+    return conn;
+}
+
+int 
+open(mixed *tls,int port)
+{
+    return FALSE;
+}
+
+void
+close(mixed *tls, int force)
+{
+}
+
diff -ruN dgd/mud/kernel/obj/binary.c dgd-net/mud/kernel/obj/binary.c
--- dgd/mud/kernel/obj/binary.c	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/mud/kernel/obj/binary.c	2008-05-19 16:14:50.000000000 +0200
@@ -1,5 +1,9 @@
 # include <kernel/kernel.h>
 # include <kernel/user.h>
+# ifdef SYS_NETWORKING
+#  include <kernel/net.h>
+# endif
+
 
 inherit LIB_CONN;	/* basic connection object */
 
@@ -25,9 +29,14 @@
  * NAME:	open()
  * DESCRIPTION:	open the connection
  */
-static void open()
+static int open()
 {
     ::open(allocate(driver->query_tls_size()));
+# ifdef SYS_NETWORKING
+    return TRUE;
+# else
+    return FALSE;
+# endif
 }
 
 /*
@@ -153,6 +162,7 @@
     ::message_done(allocate(driver->query_tls_size()));
 }
 
+#ifndef SYS_NETWORKING
 /*
  * NAME:	open_datagram()
  * DESCRIPTION:	open a datagram channel for this connection
@@ -170,3 +180,50 @@
 {
     ::receive_datagram(allocate(driver->query_tls_size()), str);
 }
+#endif
+
+#ifdef SYS_NETWORKING
+
+object udpchannel;      /* UDP channel object */
+
+/*
+ * NAME:        set_udpchannel()
+ * DESCRIPTION: set the UDP channel for this connection
+ */
+void set_udpchannel(object udp, string host, int port)
+{
+    if (previous_program() == LIB_PORT) {
+        udpchannel = udp;
+        udp->add_connection(this_object(), host, port);
+    }
+}
+
+/*
+ * NAME:        receive_datagram()
+ * DESCRIPTION: receive a datagram
+ */
+void receive_datagram(mixed *tls, string str)
+{
+    if (previous_object() == udpchannel) {
+        object user;
+
+        user = query_user();
+        if (user) {
+            user->receive_datagram(str);
+        }
+    }
+}
+
+/*
+ * NAME:        datagram()
+ * DESCRIPTION: send a datagram on the UDP channel
+ */
+int datagram(string str)
+{
+    if (previous_object() == query_user() && udpchannel) {
+        return udpchannel->datagram(str);
+    }
+}
+
+#endif 
+
diff -ruN dgd/mud/kernel/obj/port.c dgd-net/mud/kernel/obj/port.c
--- dgd/mud/kernel/obj/port.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/mud/kernel/obj/port.c	2008-05-19 16:14:50.000000000 +0200
@@ -0,0 +1,49 @@
+# include <kernel/kernel.h>
+# include <kernel/user.h>
+# include <kernel/net.h>
+
+inherit LIB_PORT;
+
+/*
+ * NAME:        create()
+ * DESCRIPTION: initialize port object
+ */
+static void create(int clone)
+{
+    if (clone) {
+        ::create();
+    }
+}
+
+/*
+ * NAME:        listen()
+ * DESCRIPTION: start listening on a port
+ */
+void listen(string protocol, int port)
+{
+#ifndef SYS_NETWORKING
+    if (previous_program() == DRIVER) {
+#else
+    if (previous_program() == DRIVER || previous_program() == USERD) {
+#endif
+        ::open_port(protocol, port);
+    }
+}
+
+/*
+ * NAME:        open_connection()
+ * DESCRIPTION: don't return a user object, select it by first line of input
+ */
+static object open_connection(string ipaddr, int port)
+{
+    return nil;
+}
+
+void open(int port) {
+    ::open(allocate(DRIVER->query_tls_size()),port);
+}
+
+object connection(string ip, int port) {
+    ::connection(allocate(DRIVER->query_tls_size()),ip,port);
+}
+
diff -ruN dgd/mud/kernel/sys/binary_port.c dgd-net/mud/kernel/sys/binary_port.c
--- dgd/mud/kernel/sys/binary_port.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/mud/kernel/sys/binary_port.c	2008-05-19 16:14:50.000000000 +0200
@@ -0,0 +1,47 @@
+#include <kernel/net.h>
+#include <kernel/user.h>
+#include <kernel/kernel.h>
+
+inherit LIB_PORT;               /* basic port object */
+
+object driver;                   /* driver object */
+
+void
+create()
+{
+    ::create();
+    driver = find_object(DRIVER);
+    open_port("tcp", BINARY_PORT);   
+}
+
+object
+connection(string ip, int port)
+{
+    return ::connection(allocate(driver->query_tls_size()), ip, port);
+}
+
+void
+done()
+{
+    close_user();
+}
+
+/*
+ * NAME:	open()
+ * DESCRIPTION:	open the connection
+ */
+static int open(int port)
+{
+    ::open(allocate(driver->query_tls_size()), port);
+    return FALSE;
+}
+
+/*
+ * NAME:	close()
+ * DESCRIPTION:	close the connection
+ */
+static void close(int force)
+{
+    ::close(allocate(driver->query_tls_size()), force);
+}
+
diff -ruN dgd/mud/kernel/sys/driver.c dgd-net/mud/kernel/sys/driver.c
--- dgd/mud/kernel/sys/driver.c	2008-10-06 13:01:50.000000000 +0200
+++ dgd-net/mud/kernel/sys/driver.c	2008-05-28 22:39:47.000000000 +0200
@@ -4,6 +4,12 @@
 # include <kernel/access.h>
 # include <kernel/user.h>
 # include <kernel/tls.h>
+# ifdef __NETWORK_PACKAGE__
+# ifndef SYS_NETWORKING
+# define SYS_NETWORKING
+# endif
+#  include <kernel/net.h>
+# endif
 # include <status.h>
 # include <trace.h>
 
@@ -16,9 +22,18 @@
 object initd;		/* init manager object */
 object objectd;		/* object manager object */
 object errord;		/* error manager object */
+# ifdef SYS_NETWORKING
+static object port_master;      /* port master object */
+static object telnet;           /* default telnet port object */
+static object binary;           /* default binary port object */
+static object emergency;        /* emergency port object */
+# endif
+
 int tls_size;		/* thread local storage size */
 int mp_ready;		/* prepared for MP */
 
+
+
 /*
  * NAME:	creator()
  * DESCRIPTION:	get creator of file
@@ -408,6 +423,10 @@
     call_other(accessd = load(ACCESSD), "???");
     call_other(userd = load(USERD), "???");
     call_other(load(DEFAULT_WIZTOOL), "???");
+# ifdef SYS_NETWORKING
+    call_other(port_master = load(PORT_OBJECT), "???");
+    call_other(emergency = load(PORT_EMERGENCY), "???");
+# endif
 
     /* initialize other users as resource owners */
     users = (accessd->query_users() - ({ "System" })) | ({ "admin" });
@@ -432,8 +451,13 @@
 	    shutdown();
 	    return;
 	}
+# ifdef SYS_NETWORKING
+    } else {
+        call_other(telnet = load(PORT_TELNET),"???");
+        call_other(binary = load(PORT_BINARY),"???");
+        rsrcd->rsrc_incr("System", "objects", nil, 2, 1);
+#endif
     }
-
     message("Initialization complete.\n\n");
 }
 
@@ -477,7 +501,19 @@
 	    call_other(initd, "reboot");
 	}
     }
-
+# ifdef SYS_NETWORKING
+    if (telnet) {
+        telnet->listen("telnet", TELNET_PORT);
+    }
+    if (binary) {
+        binary->listen("tcp", BINARY_PORT);
+    }
+    if(!emergency) {
+      emergency = clone_object(port_master);
+      rsrcd->rsrc_incr("System", "objects", nil, 1, 1);
+    }
+    emergency->listen("tcp", EMERGENCY_PORT);
+# endif
     message("State restored.\n\n");
 }
 
diff -ruN dgd/mud/kernel/sys/emergency_port.c dgd-net/mud/kernel/sys/emergency_port.c
--- dgd/mud/kernel/sys/emergency_port.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/mud/kernel/sys/emergency_port.c	2008-05-19 16:14:50.000000000 +0200
@@ -0,0 +1,47 @@
+#include <kernel/net.h>
+#include <kernel/user.h>
+#include <kernel/kernel.h>
+
+inherit LIB_PORT;               /* basic port object */
+
+object driver;                   /* driver object */
+
+void
+create()
+{
+    ::create();
+    driver = find_object(DRIVER);
+    open_port("tcp", EMERGENCY_PORT);   
+}
+
+object
+connection(string ip, int port)
+{
+    return ::connection(allocate(driver->query_tls_size()), ip, port);
+}
+
+void
+done()
+{
+    close_user();
+}
+
+/*
+ * NAME:	open()
+ * DESCRIPTION:	open the connection
+ */
+static int open(int port)
+{
+    ::open(allocate(driver->query_tls_size()), port);
+    return FALSE;
+}
+
+/*
+ * NAME:	close()
+ * DESCRIPTION:	close the connection
+ */
+static void close(int force)
+{
+    ::close(allocate(driver->query_tls_size()), force);
+}
+
diff -ruN dgd/mud/kernel/sys/telnet_port.c dgd-net/mud/kernel/sys/telnet_port.c
--- dgd/mud/kernel/sys/telnet_port.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/mud/kernel/sys/telnet_port.c	2008-05-19 16:14:50.000000000 +0200
@@ -0,0 +1,47 @@
+#include <kernel/net.h>
+#include <kernel/user.h>
+#include <kernel/kernel.h>
+
+inherit LIB_PORT;               /* basic port object */
+
+object driver;                   /* driver object */
+
+void
+create()
+{
+    ::create();
+    driver = find_object(DRIVER);
+    open_port("telnet", TELNET_PORT);   
+}
+
+object
+connection(string ip, int port)
+{
+    return ::connection(allocate(driver->query_tls_size()), ip, port);
+}
+
+void
+done()
+{
+    close_user();
+}
+
+/*
+ * NAME:	open()
+ * DESCRIPTION:	open the connection
+ */
+static int open(int port)
+{
+    ::open(allocate(driver->query_tls_size()), port);
+    return FALSE;
+}
+
+/*
+ * NAME:	close()
+ * DESCRIPTION:	close the connection
+ */
+static void close(int force)
+{
+    ::close(allocate(driver->query_tls_size()), force);
+}
+
diff -ruN dgd/mud/kernel/sys/userd.c dgd-net/mud/kernel/sys/userd.c
--- dgd/mud/kernel/sys/userd.c	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/mud/kernel/sys/userd.c	2008-05-19 16:14:50.000000000 +0200
@@ -1,11 +1,18 @@
 # include <kernel/kernel.h>
 # include <kernel/user.h>
+# ifdef SYS_NETWORKING
+#  include <kernel/net.h>
+#  define PORT  PORT_OBJECT
+# else
+#  define PORT  DRIVER
+# endif
 # include <status.h>
 
 
 object *users;		/* user mappings */
 mapping names;		/* name : connection object */
 object *connections;	/* saved connections */
+mapping listeners_telnet, listeners_tcp; /* port objects */
 mapping telnet, binary;	/* port managers */
 
 /*
@@ -18,6 +25,7 @@
     if (!find_object(TELNET_CONN)) { compile_object(TELNET_CONN); }
     if (!find_object(BINARY_CONN)) { compile_object(BINARY_CONN); }
     if (!find_object(DEFAULT_USER)) { compile_object(DEFAULT_USER); }
+    if (!find_object(PORT_OBJECT)) { compile_object(PORT_OBJECT); }
 
     /* initialize user arrays */
     users = ({ });
@@ -32,7 +40,7 @@
  */
 object telnet_connection(mixed *tls, int port)
 {
-    if (previous_program() == DRIVER) {
+    if (previous_program() == PORT) {
 	object conn;
 
 	conn = clone_object(TELNET_CONN);
@@ -47,7 +55,7 @@
  */
 object binary_connection(mixed *tls, int port)
 {
-    if (previous_program() == DRIVER) {
+    if (previous_program() == PORT) {
 	object conn;
 
 	conn = clone_object(BINARY_CONN);
@@ -57,6 +65,49 @@
 }
 
 /*
+ * NAME:
+ * DESCRIPTION:
+ */
+private void start_telnet_listener(int port)
+{
+    if(!listeners_telnet) {
+        listeners_telnet = ([ ]);
+    }
+    if(!listeners_tcp) {
+        listeners_tcp = ([ ]);
+    }
+
+    if(!listeners_telnet[port] && !listeners_tcp[port]) {
+       listeners_telnet[port] = clone_object(PORT_OBJECT);
+       listeners_telnet[port]->listen("telnet",port);
+    } else {
+       error("Port "+port+" is already in use.");
+    }
+}
+
+/*
+ * NAME:
+ * DESCRIPTION:
+ */
+private void start_tcp_listener(int port) 
+{
+    if(!listeners_telnet) {
+        listeners_telnet = ([ ]);
+    }
+
+    if(!listeners_tcp) {
+        listeners_tcp = ([ ]);
+    }
+
+    if(!listeners_telnet[port] && !listeners_tcp[port]) {
+        listeners_tcp[port] = clone_object(PORT_OBJECT);
+        listeners_tcp[port]->listen("tcp",port);
+    } else {
+        error("Port "+port+" is already in use.");
+    }
+}
+
+/*
  * NAME:	set_telnet_manager()
  * DESCRIPTION:	set the telnet manager object, which determines what the
  *		user object is, based on the first line of input
@@ -67,7 +118,11 @@
 	if (!telnet) {
 	    telnet = ([ ]);
 	}
+        if(!port) port = TELNET_PORT;
 	telnet[port] = manager;
+        DRIVER->message("telnet manager for port "+port+ " is now "+
+          object_name(manager)+"\n");
+        start_telnet_listener(port);
     }
 }
 
@@ -82,7 +137,11 @@
 	if (!binary) {
 	    binary = ([ ]);
 	}
+        if(!port) port = BINARY_PORT;
 	binary[port] = manager;
+        DRIVER->message("binary manager for port "+port+ " is now "+
+          object_name(manager)+"\n");
+        start_tcp_listener(port);
     }
 }
 
@@ -100,6 +159,7 @@
 	user = names[str];
 	if (!user) {
 	    user = telnet[port];
+            if(!user) user = binary[port];
 	    if (user) {
 		user = (object LIB_USER) user->select(str);
 	    } else {
@@ -123,7 +183,8 @@
 	user = names[str];
 	if (!user) {
 	    user = binary[port];
-	    if (user && (str != "admin" || port != 0)) {
+            if(!user) user = telnet[port];
+	    if (user && (str != "admin" || port != EMERGENCY_PORT)) {
 		user = (object LIB_USER) user->select(str);
 	    } else {
 		user = clone_object(DEFAULT_USER);
diff -ruN dgd/mud/usr/System/initd.c dgd-net/mud/usr/System/initd.c
--- dgd/mud/usr/System/initd.c	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/mud/usr/System/initd.c	2008-05-19 16:14:50.000000000 +0200
@@ -0,0 +1,32 @@
+# include <kernel/kernel.h>
+
+private void
+load(string filename)
+{
+    if (!find_object(filename)) {
+        compile_object(filename);
+    }
+}
+
+static void
+create()
+{
+    load("/kernel/sys/telnet_port");
+    load("/kernel/sys/binary_port");
+}
+
+void
+prepare_reboot()
+{
+    if (previous_program() == DRIVER) {
+        /* ... */
+    }
+}
+
+void
+reboot()
+{
+    if (previous_program() == DRIVER) {
+        /* ... */
+    }
+}
diff -ruN dgd/mud.dgd dgd-net/mud.dgd
--- dgd/mud.dgd	2008-10-06 13:01:50.000000000 +0200
+++ dgd-net/mud.dgd	2008-10-07 22:14:26.000000000 +0200
@@ -1,16 +1,17 @@
 telnet_port	= 6047;			/* telnet port number */
 binary_port	= 6048;			/* binary port number */
-directory	= "/home/dworkin/dgd/mud";/* base directory (MUST be absolute) */
+directory	= "/home/bart/phantasmal/dgd/mud";/* base directory (MUST be absolute) */
 users		= 40;			/* max # of users */
 editors		= 40;			/* max # of editor sessions */
+ports           = 8;                    /* max # of open ports */
 ed_tmpfile	= "../tmp/ed";		/* proto editor tmpfile */
 swap_file	= "../tmp/swap";	/* swap file */
-swap_size	= 1024;			/* # sectors in swap file */
-cache_size	= 50;			/* # sectors in swap cache */
-sector_size	= 512;			/* swap sector size */
-swap_fragment	= 32;			/* fragment to swap out */
-static_chunk	= 64512;		/* static memory chunk */
-dynamic_chunk	= 261120;		/* dynamic memory chunk */
+swap_size	= 65535;		/* # sectors in swap file */
+cache_size	= 1200;			/* # sectors in swap cache */
+sector_size	= 4096;			/* swap sector size */
+swap_fragment	= 50;			/* fragment to swap out */
+static_chunk	= 258048;		/* static memory chunk */
+dynamic_chunk	= 1044480;		/* dynamic memory chunk */
 dump_file	= "../dump";		/* dump file */
 dump_interval	= 3600;			/* dump interval in seconds */
 
@@ -22,5 +23,5 @@
 create		= "_F_create";		/* name of create function */
 
 array_size	= 1000;			/* max array size */
-objects		= 500;			/* max # of objects */
+objects		= 50000;			/* max # of objects */
 call_outs	= 100;			/* max # of call_outs */
diff -ruN dgd/README.NET dgd-net/README.NET
--- dgd/README.NET	1970-01-01 01:00:00.000000000 +0100
+++ dgd-net/README.NET	2008-05-20 17:25:24.000000000 +0200
@@ -0,0 +1,44 @@
+DGD-1.2.144-NET-02
+
+This patch is highly experimental, and very likely incomplete.
+Don't blame me or any of the other people involved with the
+old network package, you have been warned.
+
+It works for my own mud, but this is not thoroughly tested
+yet.
+
+This patch is based on the original network package and the
+experimental network package for DGD 1.2.37, adapted for
+modern dgd versions and extended to handle connect() in non 
+blocking mode. 
+
+It also includes the ansi patch.
+
+For copyright information on the original code, see the
+Copyright files in this directory
+
+Included is a network enabled kernel. This is merely an example,
+I do not use the kernel library myself.
+
+Tested: 
+1. open_port() and listening for tcp connections
+2. accepting incomming tcp connections
+3. making outgoing tcp connections.
+
+Untested: 
+1. UDP
+2. long term testing.
+
+What doesn't work:
+
+IPv6 support is not implemented by this package, and has been
+disabled.
+
+For questions, bugs etc please goto http://lpmuds.net/forum/index.php?board=2.0
+Please send patches to aidil@wotf.org
+
+Please note: This package is NOT supported by Dworkin, and won't be supported
+on the dgd mailinglist. For any problems, bugs and such, aidil@wotf.org or the
+lpmuds.net forums are the place to go. Please report possible security problems
+directly to aidil@wotf.org
+
diff -ruN dgd/src/comm.c dgd-net/src/comm.c
--- dgd/src/comm.c	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/src/comm.c	2009-03-02 20:33:53.000000000 +0100
@@ -1,3 +1,16 @@
+/*
+ * comm.c $Revision$
+ *
+ * Modified comm.c for use with the networking package
+ *
+ * Original by Dworkin (dworkin@dworkin.nl)
+ * This version by Aidil (aidil@wotf.org)
+ *
+ * This file includes work by many others, see the included Copyright.NET file.
+ * If that file is not included, please contact me (aidil@wotf.org) and inform
+ * me about where you got the file from.
+ *
+ */
 # define INCLUDE_TELNET
 # include "dgd.h"
 # include "str.h"
@@ -7,6 +20,7 @@
 # include "data.h"
 # include "comm.h"
 # include "version.h"
+# include <errno.h>
 
 # ifndef TELOPT_LINEMODE
 # define TELOPT_LINEMODE	34	/* linemode option */
@@ -14,6 +28,12 @@
 # define MODE_EDIT		0x01
 # endif
 
+#ifndef NETWORK_PACKAGE
+#ifdef USE_NONBLOCK
+#undef USE_NONBLOCK
+#endif
+#endif
+
 # define MAXIACSEQLEN		7	/* longest IAC sequence sent */
 
 typedef struct _user_ {
@@ -21,7 +41,11 @@
     struct _user_ *prev;	/* preceding user */
     struct _user_ *next;	/* next user */
     struct _user_ *flush;	/* next in flush list */
-    char flags;			/* connection flags */
+#ifdef NETWORK_PACKAGE
+    short flags;                /* connection flags */
+#else
+    char flags;		        /* connection flags */
+#endif
     char state;			/* telnet state */
     short newlines;		/* # of newlines in input buffer */
     connection *conn;		/* connection */
@@ -32,6 +56,8 @@
     ssizet osdone;		/* bytes of output string done */
 } user;
 
+
+
 /* flags */
 # define CF_BINARY	0x00	/* binary connection */
 # define  CF_UDP	0x02	/* receive UDP datagrams */
@@ -44,6 +70,9 @@
 # define CF_FLUSH	0x20	/* in flush list */
 # define CF_OUTPUT	0x40	/* pending output */
 # define CF_ODONE	0x80	/* output done */
+# define CF_PORT      0x0100    /* port (listening) connection */
+# define CF_DATAGRAM  0x0200    /* independent UDP socket */
+# define CF_OPENDING  0x0400    /* waiting for connect() to complete */
 
 /* state */
 # define TS_DATA	0
@@ -61,9 +90,18 @@
 static user *freeuser;		/* linked list of free users */
 static user *flush;		/* flush list */
 static int maxusers;		/* max # of users */
+#ifdef NETWORK_PACKAGE
+static int maxports;		/* max # of ports */
+static int nports;		/* # of ports */
+#endif
 static int nusers;		/* # of users */
 static int odone;		/* # of users with output done */
 static long newlines;		/* # of newlines in all input buffers */
+#ifdef NETWORK_PACKAGE
+#ifdef USE_NONBLOCK
+static short opending;          /* # of users with connect() pending */
+#endif
+#endif
 static uindex this_user;	/* current user */
 static int ntport, nbport;	/* # telnet/binary ports */
 static int nexttport;		/* next telnet port to check */
@@ -74,33 +112,150 @@
  * NAME:	comm->init()
  * DESCRIPTION:	initialize communications
  */
+#ifdef NETWORK_PACKAGE
+bool comm_init(n, p, thosts, bhosts, tports, bports, ntelnet, nbinary)
+int n, p, ntelnet, nbinary;
+#else
 bool comm_init(n, thosts, bhosts, tports, bports, ntelnet, nbinary)
 int n, ntelnet, nbinary;
+#endif
 char **thosts, **bhosts;
 unsigned short *tports, *bports;
 {
     register int i;
     register user *usr;
 
+#ifdef NETWORK_PACKAGE
+    maxusers = n;
+    maxports = p;
+    users = ALLOC(user, (maxusers + maxports));
+#else
     users = ALLOC(user, maxusers = n);
-    for (i = n, usr = users + i; i > 0; --i) {
+#endif
+#ifdef NETWORK_PACKAGE
+    for (i = (n+p), usr = users + i; i > 0; --i) {
+#else
+    for (i = n+p, user = users + i; i > 0; --i) {
+#endif
 	--usr;
 	usr->oindex = OBJ_NONE;
 	usr->next = usr + 1;
     }
-    users[n - 1].next = (user *) NULL;
+    users[n+p - 1].next = (user *) NULL;
     freeuser = usr;
     lastuser = (user *) NULL;
     flush = (user *) NULL;
     nusers = odone = newlines = 0;
+#ifdef NETWORK_PACKAGE
+    nports = 0;
+#ifdef USE_NONBLOCK
+    opending = 0;
+#endif
+#endif
     this_user = OBJ_NONE;
 
     sprintf(ayt, "\15\12[%s]\15\12", VERSION);
 
     nexttport = nextbport = 0;
+
+#ifdef NETWORK_PACKAGE
+    return conn_init(n+p, thosts, bhosts, tports, bports, ntport = ntelnet,
+                     nbport = nbinary);
+#else
     return conn_init(n, thosts, bhosts, tports, bports, ntport = ntelnet,
 		     nbport = nbinary);
+#endif
+}
+
+#ifdef NETWORK_PACKAGE
+void comm_openport(f, obj, protocol, portnr)
+frame *f;
+object *obj;
+unsigned char protocol;
+unsigned short portnr;
+{
+    register connection *conn;
+    uindex olduser;
+    short flags;
+    register user *usr;
+    dataspace *data;
+    array *arr;
+    value val;
+    int i;
+
+    if (nports >= maxports) 
+	error("Max number of port objects exceeded");
+
+    switch (protocol)
+    {
+    case P_TELNET:
+	flags=CF_TELNET|CF_PORT;
+	protocol=P_TCP;
+	break;
+    case P_UDP:
+	flags=CF_DATAGRAM|CF_PORT;
+	break;
+    case P_TCP:
+	flags=CF_PORT;
+	break;
+    default:
+	error("Unknown protocol");
+    }
+
+    conn=(connection *)conn_openlisten(protocol, portnr);
+    if (conn==(connection *) NULL)
+	error("Can't open port");
+    
+    usr=freeuser;
+    freeuser=usr->next;
+    if (lastuser != (user *) NULL) {
+	usr->prev=lastuser->prev;
+	usr->prev->next=usr;
+	usr->next=lastuser;
+	lastuser->prev=usr;
+    } else {
+	usr->prev=usr;
+	usr->next=usr;
+	lastuser=usr;
+    }
+    d_wipe_extravar(data=o_dataspace(obj));
+    switch (protocol)
+    {
+    case P_TCP:
+	arr = arr_new(data, 3L);
+	arr->elts[0] = zero_int;
+	arr->elts[1] = arr->elts[2] = nil_value;
+	PUT_ARRVAL_NOREF(&val, arr);
+	d_set_extravar(data, &val);
+	break;
+    case P_UDP:
+	arr=arr_new(data, 4L);
+	arr->elts[0]=zero_int;
+	arr->elts[1]=nil_value;
+	arr->elts[2]=nil_value;
+	arr->elts[3]=nil_value;
+	PUT_ARRVAL_NOREF(&val, arr);
+	d_set_extravar(data, &val);
+	break;
+    }
+    usr->oindex=obj->index;
+    obj->flags |= O_USER;
+    obj->etabi = usr-users;
+    usr->conn = conn;
+    usr->outbuf = (string *) NULL;
+    usr->osdone = 0;
+    usr->flags=flags;
+    olduser=this_user;
+    this_user=obj->index;
+    (--f->sp)->type=T_INT;
+    f->sp->u.number=conn_at(conn);
+    if (i_call(f, obj, (array *) NULL, "open", 4, TRUE, 1)) {
+	i_del_value(f->sp++);
+    }
+    nports++;
+    this_user=olduser;
 }
+#endif
 
 /*
  * NAME:	comm->finish()
@@ -111,6 +266,7 @@
     conn_finish();
 }
 
+#ifndef NETWORK_PACKAGE
 /*
  * NAME:	comm->listen()
  * DESCRIPTION:	start listening on telnet port and binary port
@@ -119,6 +275,7 @@
 {
     conn_listen();
 }
+#endif
 
 /*
  * NAME:	addtoflush()
@@ -214,6 +371,81 @@
     return usr;
 }
 
+#ifdef NETWORK_PACKAGE
+void
+comm_connect(f, obj, addr, protocol, port)
+frame *f;
+object *obj;
+char *addr;
+unsigned char protocol;
+unsigned short port;
+{
+    register connection *conn;
+    register user *usr;
+    uindex olduser;
+    
+    if (nusers >= maxusers)
+	error("Max number of connection objects exceeded");
+    
+    conn=(connection *)conn_connect(addr, port);
+    
+    if (conn==(connection *) NULL)
+	error("Can't connect to server");
+    
+    usr=comm_new(f,obj, conn, (protocol==P_TELNET));
+    addtoflush(usr, d_get_extravar(o_dataspace(obj))->u.array);
+#ifdef USE_NONBLOCK
+    opending++;
+    usr->flags |= CF_OPENDING;
+#else
+    olduser=this_user;
+    this_user=obj->index;
+    if (i_call(f, obj, (array *) NULL, "open", 4, TRUE, 0)) {
+	i_del_value(f->sp++);
+    }
+    this_user=olduser;
+#endif
+}
+
+int comm_senddatagram(obj, str, ip, port)
+object * obj;
+string * str;
+string * ip;
+int port;
+{
+    register user *usr;
+    dataspace *data;
+    array *arr;
+    register value *v1, *v2, *v3, *v4;
+    value val;
+    
+    usr = &users[EINDEX(obj->etabi)];
+
+    if ((usr->flags & (CF_PORT|CF_DATAGRAM)) != (CF_PORT|CF_DATAGRAM)) {
+	error("Object is not a udp port object");
+    }
+    if (!conn_checkaddr(ip->text)) {
+	error("Not a IP address");
+    }
+    arr=d_get_extravar(data=obj->data)->u.array;
+    if (!(usr->flags & CF_FLUSH)) {
+	addtoflush(usr, arr);
+    }
+
+    v1=arr->elts +1;/*used for string*/
+    v2=arr->elts +2;/*used for ip */
+    v3=arr->elts +3;/*used for port*/
+    usr->flags |= CF_OUTPUT;
+    PUT_STRVAL_NOREF(&val, str);
+    d_assign_elt(data, arr, v1, &val);
+    PUT_STRVAL_NOREF(&val, ip);
+    d_assign_elt(data, arr, v2, &val);
+    PUT_INTVAL(&val, port);
+    d_assign_elt(data, arr, v3, &val);
+    return str->len;
+}
+#endif
+
 /*
  * NAME:	comm->del()
  * DESCRIPTION:	delete a connection
@@ -235,6 +467,13 @@
 	}
 	obj->flags &= ~O_USER;
     }
+    /* make sure opending gets decreased if we were still waiting for
+     * connection esteblishment when receiving a close event.
+     */
+    if(usr->flags & CF_OPENDING) {
+        opending--;
+        usr->flags &= ~CF_OPENDING;
+    }
     olduser = this_user;
     if (ec_push((ec_ftn) NULL)) {
 	this_user = olduser;
@@ -410,7 +649,7 @@
 		 */
 		*q++ = CR;
 		size++;
-	    } else if ((*p & 0x7f) < ' ' && *p != HT && *p != BEL && *p != BS) {
+	    } else if ((*p & 0x7f) < ' ' && *p != HT && *p != BEL && *p != BS && *p != ESC) {
 		/*
 		 * illegal character
 		 */
@@ -528,6 +767,38 @@
     }
 }
 
+#ifdef NETWORK_PACKAGE
+static void comm_udpflush(usr, obj, data, arr)
+register user *usr;
+object *obj;
+dataspace *data;
+array *arr;
+{
+    register value *v;
+    register int i,j;
+    register char *buf;
+    int res;
+
+    v=d_get_elts(arr);
+    if (!conn_wrdone(usr->conn)) {
+	return;
+    }
+    buf=v[1].u.string->text;
+    res=conn_udpsend(usr->conn, 
+      buf,
+      strlen(buf), 
+      v[2].u.string->text,
+      (unsigned short) v[3].u.number
+    );
+    if (res==-1) {
+      /* EAGAIN occured, datagram could not be sent */
+    }
+    usr->flags &= ~CF_OUTPUT;
+    usr->flags |= CF_ODONE;
+    odone++;
+}
+#endif
+
 /*
  * NAME:	comm->uflush()
  * DESCRIPTION:	flush output buffers for a single user only
@@ -639,16 +910,24 @@
 	    usr->outbuf = (string *) NULL;
 	}
 	if (usr->flags & CF_OUTPUT) {
+#ifdef NETWORK_PACKAGE
+          if ( (usr->flags & CF_DATAGRAM) ) {
+              comm_udpflush(usr, obj, obj->data, arr);
+          } else
+#endif
 	    comm_uflush(usr, obj, obj->data, arr);
-	}
-
+        }
 	/*
 	 * disconnect
 	 */
 	if ((obj->flags & O_SPECIAL) != O_USER) {
 	    d_wipe_extravar(obj->data);
 	    conn_del(usr->conn);
+#ifdef NETWORK_PACKAGE
+	    if (usr->flags & (CF_TELNET|CF_PORT) == CF_TELNET) {
+#else
 	    if (usr->flags & CF_TELNET) {
+#endif
 		newlines -= usr->newlines;
 		FREE(usr->inbuf - 1);
 	    }
@@ -668,7 +947,11 @@
 	    }
 	    usr->next = freeuser;
 	    freeuser = usr;
-	    --nusers;
+            if(usr->flags & CF_PORT) {
+              --nports;
+            } else {
+	      --nusers;
+            }
 	}
 
 	arr_del(arr);
@@ -774,14 +1057,26 @@
 
     if (newlines != 0 || odone != 0) {
 	timeout = mtime = 0;
+#ifdef USE_NONBLOCK
+    } else if(opending != 0) {
+        timeout = 0;
+        if(mtime > 250) {
+            mtime = 250;
+        }
+#endif
     }
     n = conn_select(timeout, mtime);
+#ifdef USE_NONBLOCK
+    if ((n <= 0) && (newlines == 0) && (odone == 0) && (opending == 0)) {
+#else
     if (n <= 0 && newlines == 0 && odone == 0) {
+#endif
 	/*
 	 * call_out to do, or timeout
 	 */
 	return;
     }
+    
 
     if (ec_push(errhandler)) {
 	endthread();
@@ -789,6 +1084,7 @@
 	return;
     }
 
+#ifndef NETWORK_PACKAGE
     if (ntport != 0 &&nusers < maxusers) {
 	n = nexttport;
 	do {
@@ -837,10 +1133,62 @@
     }
 
     for (i = nusers; i > 0; --i) {
+#else
+    for (i = nusers + nports; i > 0; --i) {
+#endif
 	usr = lastuser;
 	lastuser = usr->next;
 
 	obj = OBJ(usr->oindex);
+
+
+#ifdef NETWORK_PACKAGE
+#ifdef USE_NONBLOCK
+        /*
+         * Check if we have an event pending from connect() and if so, handle it.
+         */
+        if(usr->flags & CF_OPENDING) {
+            int retval;
+            uindex old_user;
+            retval = conn_check_connected(usr->conn);
+            /*
+             * Something happened to the connection..
+             * its either connected or in error state now.
+             */
+            if(retval != 0) {
+                opending--;
+                usr->flags &= ~CF_OPENDING;
+                old_user = this_user;
+                this_user = obj->index;
+                /*
+                 * Error, report it to the user object.
+                 */
+                if(retval < 0) {
+                    PUSH_STRVAL(f, str_new(strerror(errno), strlen(strerror(errno))));
+                    if (i_call(f, obj, (array *) NULL, "receive_error", 13, TRUE, 1)) {
+                       i_del_value(f->sp++);
+                    }
+                    endthread();
+                /*
+                 * Connection completed, call open in the user object.
+                 */
+                } else if(retval > 0) {
+                    if (i_call(f, obj, (array *) NULL, "open", 4, TRUE, 0)) {
+                       i_del_value(f->sp++);
+                    }
+                    endthread();
+                }
+                this_user = old_user;
+            }
+            /*
+             * Don't do anything else for user objects with pending
+             * connects.
+             */
+            continue;
+        }
+#endif
+#endif
+
 	if (usr->flags & CF_OUTPUT) {
 	    dataspace *data;
 
@@ -852,10 +1200,20 @@
 	    usr->flags &= ~CF_ODONE;
 	    --odone;
 	    this_user = obj->index;
-	    if (i_call(f, obj, (array *) NULL, "message_done", 12, TRUE, 0)) {
+            /*
+             * message_done for tcp, datagram_done for udp
+             */
+            if(usr->flags & CF_DATAGRAM) {
+              if (i_call(f, obj, (array *) NULL, "datagram_done", 13, TRUE, 0)) {
+                i_del_value(f->sp++);
+                endthread();
+              }
+            } else {
+	      if (i_call(f, obj, (array *) NULL, "message_done", 12, TRUE, 0)) {
 		i_del_value(f->sp++);
 		endthread();
-	    }
+	      }
+            }
 	    this_user = OBJ_NONE;
 	    if (obj->count == 0) {
 		break;	/* continue, unless the connection was closed */
@@ -866,7 +1224,80 @@
 	    continue;	/* no input on this connection */
 	}
 
-	if (usr->flags & CF_TELNET) {
+#ifdef NETWORK_PACKAGE
+	if ( (usr->flags & (CF_DATAGRAM | CF_PORT))==(CF_PORT|CF_DATAGRAM)) {
+	    char *addr;
+	    int port;
+	    n= conn_udpreceive(usr->conn, buffer, BINBUF_SIZE, &addr, &port);
+	    if (n >=0) {
+		PUSH_STRVAL(f, str_new(buffer, (long) n));
+		PUSH_STRVAL(f, str_new(addr, strlen(addr)));
+		PUSH_INTVAL(f, port);
+		if (i_call(f, obj, (array *) NULL, "receive_datagram", 16,
+			   TRUE, 3)) {
+		    i_del_value(f->sp++);
+		    endthread();
+		}
+	    }
+	    continue;
+	}
+
+	if ( (usr->flags & (CF_PORT | CF_DATAGRAM))==CF_PORT) {
+	    if (nusers <= maxusers) {
+		connection * conn;
+		char ip[40];
+		user *newusr;
+		uindex olduser;
+
+		conn=(connection *)conn_accept(usr->conn);
+
+		if (conn==(connection *) NULL) {
+		    break;
+		}
+                if(nusers == maxusers) {
+                    conn_del(conn);
+                    error("Maximum number of users exceeded");
+                }
+
+		if (ec_push((ec_ftn) NULL)) {
+		    conn_del(conn);
+		    error((char *) NULL);
+		}
+		(--f->sp)->type=T_STRING;
+		conn_ipnum(conn,ip);
+		PUT_STRVAL(f->sp, str_new(ip, strlen(ip)));
+		(--f->sp)->type=T_INT;
+		f->sp->u.number=conn_at(conn);
+		if (!i_call(f, OBJ(usr->oindex), (array *) NULL, "connection",
+			    10, TRUE, 2)) {
+		    conn_del(conn);
+		    error("Missing connection()-function");
+		}
+		if (f->sp->type != T_OBJECT) {
+		    conn_del(conn);
+		    error("object->connection() did not return a persistent object");
+		}
+		obj=OBJ(f->sp->oindex);
+		f->sp++;
+		newusr=comm_new(f,obj, conn, usr->flags & CF_TELNET);
+		ec_pop();
+		endthread();
+		
+		newusr->flags |=CF_PROMPT;
+		addtoflush(newusr, 
+			   d_get_extravar(o_dataspace(obj))->u.array);
+		olduser=this_user;
+		this_user=obj->index;
+		if (i_call(f, obj, (array *) NULL, "open", 4, TRUE, 0)) {
+		    i_del_value(f->sp++);
+		}
+		this_user=olduser;
+	    }
+	    continue;
+	    
+	}
+#endif
+	if ( usr->flags & CF_TELNET) {
 	    /*
 	     * telnet connection
 	     */
@@ -1203,33 +1634,76 @@
  * NAME:	comm->users()
  * DESCRIPTION:	return an array with all user objects
  */
+#ifdef NETWORK_PACKAGE
+array *comm_users(data, ports)
+dataspace *data;
+bool ports;
+#else
 array *comm_users(data)
 dataspace *data;
+#endif
 {
     array *a;
-    register int i, n;
+    register int i, n, f;
     register user *usr;
     register value *v;
     register object *obj;
 
     n = 0;
-    for (i = nusers, usr = users; i > 0; usr++) {
+    for (i = (nusers + nports), usr = users; i > 0; usr++) {
 	if (usr->oindex != OBJ_NONE) {
 	    --i;
+#ifdef NETWORK_PACKAGE
+	    if (OBJR(usr->oindex)->count != 0
+		&& ( !((f=usr->flags & CF_PORT) || ports) || f &&ports)) {
+		n++;
+	    }
+#else
 	    if (OBJR(usr->oindex)->count != 0) {
 		n++;
 	    }
+#endif
 	}
     }
 
     a = arr_new(data, (long) n);
     v = a->elts;
     for (usr = users; n > 0; usr++) {
+#ifdef NETWORK_PACKAGE
+	if (usr->oindex != OBJ_NONE && (obj=OBJR(usr->oindex))->count != 0
+	    && ( !((f=usr->flags & CF_PORT) || ports) || f &&ports)) {
+	    PUT_OBJVAL(v, obj);
+	    v++;
+	    --n;
+	}
+#else
 	if (usr->oindex != OBJ_NONE && (obj=OBJR(usr->oindex))->count != 0) {
 	    PUT_OBJVAL(v, obj);
 	    v++;
 	    --n;
 	}
+#endif
     }
     return a;
 }
+
+#ifdef NETWORK_PACKAGE
+/*
+ * NAME:        comm->is_connection()
+ * DESCRIPTION: is this REALLY a user object?
+ */
+bool comm_is_connection(obj)
+object *obj;
+{
+    register user *usr;
+
+    if((obj->flags & O_SPECIAL) == O_USER) {
+      usr = &users[EINDEX(obj->etabi)];
+      if((usr->flags & CF_PORT) != CF_PORT) {
+        return 1;
+      }
+    }
+    return 0;
+}
+#endif
+
diff -ruN dgd/src/comm.h dgd-net/src/comm.h
--- dgd/src/comm.h	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/src/comm.h	2009-03-02 20:33:53.000000000 +0100
@@ -1,3 +1,14 @@
+#ifdef NODEFBUFSIZE
+# define OUTBUF_SIZE  8192
+# define BINBUF_SIZE  8192
+#endif
+
+#ifdef NETWORK_PACKAGE
+# define  P_TCP      6
+# define  P_UDP      17
+# define  P_TELNET   1
+#endif
+
 typedef struct _connection_ connection;
 
 extern bool	   conn_init	 P((int, char**, char**, unsigned short*,
@@ -21,7 +32,7 @@
 extern void	   conn_ipnum	 P((connection*, char*));
 extern void	   conn_ipname	 P((connection*, char*));
 
-extern bool	comm_init	P((int, char**, char**, unsigned short*,
+extern bool	comm_init	P((int, int, char**, char**, unsigned short*,
 				   unsigned short*, int, int));
 extern void	comm_finish	P((void));
 extern void	comm_listen	P((void));
@@ -36,4 +47,10 @@
 extern string  *comm_ip_name	P((object*));
 extern void	comm_close	P((frame*, object*));
 extern object  *comm_user	P((void));
+#ifdef NETWORK_PACKAGE
+extern bool     comm_is_connection P((object*));
+extern array   *comm_users      P((dataspace *, bool));
+#else
 extern array   *comm_users	P((dataspace*));
+#endif
+
diff -ruN dgd/src/comp/comp.c dgd-net/src/comp/comp.c
--- dgd/src/comp/comp.c	2008-10-07 22:13:44.000000000 +0200
+++ dgd-net/src/comp/comp.c	2008-10-07 22:14:26.000000000 +0200
@@ -593,8 +593,8 @@
  * NAME:	comm->init()
  * DESCRIPTION:	pretend to initialize communications
  */
-bool comm_init(n, thosts, bhosts, tports, bports, ntelnet, nbinary)
-int n, ntelnet, nbinary;
+bool comm_init(n, p, thosts, bhosts, tports, bports, ntelnet, nbinary)
+int n, p, ntelnet, nbinary;
 char **thosts, **bhosts;
 unsigned short *tports, *bports;
 {
@@ -722,11 +722,47 @@
  * NAME:	comm->users()
  * DESCRIPTION:	pretend to return an array with all user objects
  */
+#ifndef NETWORK_PACKAGE
 array *comm_users(data)
 dataspace *data;
 {
     return (array *) NULL;
 }
+#else
+array *comm_users(data, ports)
+dataspace *data;
+bool ports;
+{
+    return (array *) NULL;
+}
+
+void comm_openport(f, obj, protocol, portnr)
+frame *f;
+object *obj;
+unsigned char protocol;
+unsigned short portnr;
+{
+}
+
+void
+comm_connect(f, obj, addr, protocol, port)
+frame *f;
+object *obj;
+char *addr;
+unsigned char protocol;
+unsigned short port;
+{
+}
+
+int comm_senddatagram(obj, str, ip, port)
+object * obj;
+string * str;
+string * ip;
+int port;
+{
+    return 0;
+}
+#endif
 
 /*
  * NAME:	ed->init()
diff -ruN dgd/src/config.c dgd-net/src/config.c
--- dgd/src/config.c	2008-10-07 22:13:44.000000000 +0200
+++ dgd-net/src/config.c	2008-10-07 22:14:26.000000000 +0200
@@ -74,29 +74,31 @@
 # define OBJECTS	15
 				{ "objects",		INT_CONST, FALSE, FALSE,
 							2, UINDEX_MAX },
-# define SECTOR_SIZE	16
+# define PORTS          16 
+                                { "ports",              INT_CONST, FALSE, FALSE, 1, 32 },
+# define SECTOR_SIZE	17
 				{ "sector_size",	INT_CONST, FALSE, FALSE,
 							512, 65535 },
-# define STATIC_CHUNK	17
+# define STATIC_CHUNK	18
 				{ "static_chunk",	INT_CONST },
-# define SWAP_FILE	18
+# define SWAP_FILE	19
 				{ "swap_file",		STRING_CONST },
-# define SWAP_FRAGMENT	19
+# define SWAP_FRAGMENT	20
 				{ "swap_fragment",	INT_CONST, FALSE, FALSE,
 							0, SW_UNUSED },
-# define SWAP_SIZE	20
+# define SWAP_SIZE	21
 				{ "swap_size",		INT_CONST, FALSE, FALSE,
 							1024, SW_UNUSED },
-# define TELNET_PORT	21
+# define TELNET_PORT	22
 				{ "telnet_port",	'[', FALSE, FALSE,
 							1, USHRT_MAX },
-# define TYPECHECKING	22
+# define TYPECHECKING	23
 				{ "typechecking",	INT_CONST, FALSE, FALSE,
 							0, 2 },
-# define USERS		23
+# define USERS		24
 				{ "users",		INT_CONST, FALSE, FALSE,
-							1, EINDEX_MAX },
-# define NR_OPTIONS	24
+							1, 192 },
+# define NR_OPTIONS	25
 };
 
 
@@ -732,7 +734,9 @@
 	}
 
 	l = 0;
+
 	h = NR_OPTIONS;
+
 	for (;;) {
 	    c = strcmp(yytext, conf[m = (l + h) >> 1].name);
 	    if (c == 0) {
@@ -1190,6 +1194,7 @@
 
     /* initialize communications */
     if (!comm_init((int) conf[USERS].u.num,
+                   (int) conf[PORTS].u.num,
 		   thosts, bhosts,
 		   tports, bports,
 		   ntports, nbports)) {
@@ -1327,9 +1332,10 @@
     endthread();
     ec_pop();				/* remove guard */
 
+#ifndef NETWORK_PACKAGE
     /* start accepting connections */
     comm_listen();
-
+#endif
     return TRUE;
 }
 
diff -ruN dgd/src/host/unix/connect.c dgd-net/src/host/unix/connect.c
--- dgd/src/host/unix/connect.c	2008-12-13 18:49:02.000000000 +0100
+++ dgd-net/src/host/unix/connect.c	2009-02-09 14:35:14.000000000 +0100
@@ -10,6 +10,9 @@
 # include "hash.h"
 # include "comm.h"
 
+#undef INET6
+#undef AF_INET6
+
 # ifdef INET6		/* INET6 defined */
 #  if INET6 == 0
 #   undef INET6		/* ... but turned off */
@@ -50,6 +53,7 @@
 } ipaddr;
 
 static int in = -1, out = -1;		/* pipe to/from name resolver */
+static int addrtype;                    /* network address family */
 static ipaddr **ipahtab;		/* ip address hash table */
 static unsigned int ipahtabsz;		/* hash table size */
 static ipaddr *qhead, *qtail;		/* request queue */
@@ -58,6 +62,10 @@
 static ipaddr *lastreq;			/* last request */
 static bool busy;			/* name resolver busy */
 
+#ifdef NETWORK_PACKAGE
+connection *conn_accept(connection * conn);
+#endif
+
 
 /*
  * NAME:	ipaddr->run()
@@ -391,7 +399,6 @@
     }
 }
 
-
 struct _connection_ {
     hte chain;				/* UDP challenge hash chain */
     int fd;				/* file descriptor */
@@ -537,8 +544,13 @@
     if (!ipa_init(maxusers)) {
 	return FALSE;
     }
+/*
+    addrtype = host->h_addrtype;
+*/
+    addrtype = PF_INET;
 
     nusers = 0;
+    
     maxfd = 0;
     FD_ZERO(&infds);
     FD_ZERO(&outfds);
@@ -547,6 +559,7 @@
     npackets = 0;
     closed = 0;
 
+#ifndef NETWORK_PACKAGE
     ntdescs = ntports;
     if (ntports != 0) {
 	tdescs = ALLOC(portdesc, ntports);
@@ -559,6 +572,7 @@
 	udescs = ALLOC(portdesc, nbports);
 	memset(udescs, -1, nbports * sizeof(portdesc));
     }
+#endif
 
 # ifdef INET6
     memset(&sin6, '\0', sizeof(sin6));
@@ -695,16 +709,18 @@
     }
 
     flist = (connection *) NULL;
-    connections = ALLOC(connection, nusers = maxusers);
+    connections = ALLOC(connection, nusers = maxusers+1);
     for (n = nusers, conn = connections; n > 0; --n, conn++) {
 	conn->fd = -1;
 	conn->chain.next = (hte *) flist;
 	flist = conn;
     }
 
+#ifndef NETWORK_PACKAGE
     udphtab = ALLOC(connection*, udphtabsz = maxusers);
     memset(udphtab, '\0', udphtabsz * sizeof(connection*));
     chtab = ht_new(maxusers, UDPHASHSZ, TRUE);
+#endif
 
     return TRUE;
 }
@@ -749,6 +765,7 @@
     ipa_finish();
 }
 
+#ifndef NETWORK_PACKAGE
 /*
  * NAME:	conn->listen()
  * DESCRIPTION:	start listening on telnet port and binary port
@@ -876,6 +893,7 @@
 }
 # endif
 
+/* #ifndef NETWORK_PACKAGE */
 /*
  * NAME:	conn->accept()
  * DESCRIPTION:	accept a new ipv4 connection
@@ -918,6 +936,7 @@
 
     return conn;
 }
+/* #endif */
 
 /*
  * NAME:	conn->tnew6()
@@ -982,6 +1001,7 @@
     }
     return (connection *) NULL;
 }
+#endif
 
 /*
  * NAME:	conn->udp()
@@ -1063,7 +1083,10 @@
 	npackets -= conn->npkts;
 	FREE(conn->udpbuf);
     }
-    ipa_del(conn->addr);
+    if (conn->addr != (ipaddr *) NULL)
+    {
+      ipa_del(conn->addr);
+    }
     conn->chain.next = (hte *) flist;
     flist = conn;
 }
@@ -1450,7 +1473,7 @@
 # ifdef INET6
 	if (conn->addr->ipnum.ipv6) {
 	    struct sockaddr_in6 to;
-
+ 
 	    memset(&to, '\0', sizeof(struct sockaddr_in6));
 	    to.sin6_family = AF_INET6;
 	    memcpy(&to.sin6_addr, &conn->addr->ipnum.in.addr6,
@@ -1462,7 +1485,7 @@
 # endif
 	{
 	    struct sockaddr_in to;
-
+ 
 	    memset(&to, '\0', sizeof(struct sockaddr_in));
 	    to.sin_family = AF_INET;
 	    to.sin_addr = conn->addr->ipnum.in.addr;
@@ -1474,6 +1497,45 @@
     return -1;
 }
 
+#ifdef NETWORK_PACKAGE
+int conn_udpsend(conn, buf, len, addr, port)
+register connection *conn;
+char *buf;
+unsigned int len;
+char *addr;
+unsigned short port;
+{
+    struct sockaddr_in to;
+
+    to.sin_family=addrtype;
+    inet_aton(addr, &to.sin_addr); /* should have been checked for valid 
+				      addresses already, so it should not
+				      fail */
+    to.sin_port = htons(port);
+    if (!sendto(conn->fd, buf, len, 0, (struct sockaddr *) &to,
+		sizeof(struct sockaddr_in)))
+    {
+	if (errno==EAGAIN) {
+	    return -1;
+	}
+	perror("sendto");
+	return -2;
+    }
+    return 0;
+}
+
+/*
+ * NAME:	conn->checkaddr()
+ * DESCRIPTION:	checks for valid ip address
+ */
+int conn_checkaddr(ip)
+char *ip;
+{
+    struct in_addr dummy;
+    return inet_aton(ip, &dummy);
+}
+#endif
+
 /*
  * NAME:	conn->wrdone()
  * DESCRIPTION:	return TRUE if a connection is ready for output
@@ -1509,6 +1571,7 @@
     {
 	strcpy(buf, inet_ntoa(conn->addr->ipnum.in.addr));
     }
+
 }
 
 /*
@@ -1525,3 +1588,336 @@
 	conn_ipnum(conn, buf);
     }
 }
+
+#ifdef NETWORK_PACKAGE
+ /*
+  * Name:        conn->openlisten()
+  * DESCRIPTION: open a new listening connection
+  */
+ connection *
+ conn_openlisten(protocol, port)
+ unsigned char protocol;
+ unsigned short port;
+ {
+     struct sockaddr_in sin;  
+     connection *conn;
+     int on, n, sock,sz;
+     
+ 
+     switch (protocol){
+     case P_TCP:
+ 	sock=socket(addrtype, SOCK_STREAM, 0);
+ 	if (sock<0){
+ 	    perror("socket");
+ 	    return NULL;
+ 	}
+ 	on=1;
+ 	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on,
+ 		       sizeof(on))<0){
+ 	    perror("setsockopt");
+ 	    close(sock);
+ 	    return NULL;
+ 	}
+ #ifdef SO_OOBINLINE
+ 	on=1;
+ 	if (setsockopt(sock, SOL_SOCKET, SO_OOBINLINE, (char *) &on,
+ 		       sizeof(on))<0) {
+ 	    perror("setsockopt");
+ 	    close(sock);
+ 	    return NULL;
+ 	}
+ #endif
+ 	memset(&sin, '\0', sizeof(sin));
+ 	sin.sin_port = htons(port);
+ 	sin.sin_family = addrtype;
+ 	sin.sin_addr.s_addr = INADDR_ANY;
+ 	if (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
+ 	    perror("bind");
+ 	    close(sock);
+ 	    return NULL;
+ 	}
+ 
+ 	if (listen(sock,64)) {
+ 	    perror("listen");
+ 	    close(sock);
+ 	    return NULL;
+ 	}
+ 
+ 	FD_SET(sock, &infds);
+ 	if (maxfd < sock) {
+ 	    maxfd = sock;
+ 	}
+ 	
+ 	conn=flist;
+ 	flist = (connection *) conn->chain.next;
+ 	conn->fd=sock;
+ 	sz=sizeof(sin);
+ 	getsockname(conn->fd, (struct sockaddr *) &sin, &sz);
+ 	conn->at=ntohs(sin.sin_port);
+ 	return conn;
+     case P_UDP:
+ 	sock=socket(addrtype, SOCK_DGRAM, 0);
+ 	if (sock<0) {
+ 	    perror("socket");
+ 	    return NULL;
+ 	}
+ 	on=0;
+ 	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on,
+ 		       sizeof(on))<0) {
+ 	    perror("setsockopt");
+ 	    close(sock);
+ 	    return NULL;
+ 	}
+ 	memset(&sin, '\0', sizeof(sin));
+ 	sin.sin_port=htons(port);
+ 	sin.sin_family=addrtype;
+ 	sin.sin_addr.s_addr=INADDR_ANY;
+ 	if (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
+ 	    perror("bind");
+ 	    close(sock);
+ 	    return NULL;
+ 	}
+ 	if (fcntl(sock, F_SETFL, FNDELAY)) {
+ 	    perror("fcntl");
+ 	    close(sock);
+ 	    return NULL;
+ 	}
+ 	FD_SET(sock, &infds);
+ 	if (maxfd < sock) {
+ 	    maxfd=sock;
+ 	}
+ 	conn=flist;
+ 	flist=(connection *) conn->chain.next;
+ 	conn->fd=sock;
+ 	sz=sizeof(sin);
+ 	getsockname(conn->fd, (struct sockaddr *) &sin, &sz);
+ 	conn->at=ntohs(sin.sin_port);
+ 	return conn;
+     default:
+ 	return NULL;
+     }
+   
+ }
+ /*
+  * NAME:	conn->port()
+  * DESCRIPTION:	return the port number of a connection
+  */
+ int conn_at(conn)
+ connection *conn;
+ {
+     return conn->at;
+ }
+ 
+ /*
+  * NAME:	conn->accept()
+  * DESCRIPTION:	return a new connction structure
+  */
+ connection *conn_accept(conn)
+ connection *conn;
+ {
+     int fd, len;
+     struct sockaddr_in sin;
+     in46addr addr;
+     register connection *newconn;
+ 
+     if (!FD_ISSET(conn->fd, &readfds)) {
+ 	return (connection *) NULL;
+     }
+     
+     len = sizeof(sin);
+     fd = accept(conn->fd, (struct sockaddr *) &sin, &len);
+     if (fd < 0) {
+ 	return (connection *) NULL;
+     }
+     if (fcntl(fd, F_SETFL, FNDELAY)) {
+ 	perror("fcntl");
+ 	close(fd);
+ 	return NULL;
+     }
+ 
+     newconn=flist;
+     flist=(connection *)newconn->chain.next;
+     newconn->fd=fd;
+     newconn->chain.name = (char *) NULL;
+     newconn->udpbuf=(char *) NULL;
+     addr.in.addr = sin.sin_addr;
+     addr.ipv6 = FALSE;
+     newconn->addr = ipa_new(&addr);
+     /* newconn->addr=ipa_new(&sin.sin_addr);  */
+     newconn->at=ntohs(sin.sin_port);
+     FD_SET(fd, &infds);
+     FD_SET(fd, &outfds);
+     FD_CLR(fd, &readfds);
+     FD_SET(fd, &writefds);
+     if (fd > maxfd) {
+ 	maxfd=fd;
+     }
+
+     return newconn;
+ }
+ 
+ 
+ connection *conn_connect(addr, port)
+ char *addr;
+ unsigned short port;
+ {
+     register connection * conn;
+     register int sock;
+     int on;
+#ifdef USE_NONBLOCK
+     long arg;
+#endif
+
+     struct sockaddr_in sin;
+     in46addr inaddr;
+ 
+     if(flist == (connection *) NULL) {
+        return NULL;
+     }
+
+     sock=socket(addrtype, SOCK_STREAM, 0);
+     if (sock<0) {
+ 	perror("socket");
+ 	return NULL;
+     }
+     on=1;
+     if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, 
+ 		   sizeof(on))<0) {
+ 	perror("setsockopt");
+ 	return NULL;
+     }
+ #ifdef SO_OOBINLINE
+     on=1;
+     if (setsockopt(sock, SOL_SOCKET, SO_OOBINLINE, (char *) &on,
+ 		   sizeof(on))<0) {
+ 	perror("setsockopt");
+ 	return NULL;
+     }
+ #endif
+ #ifdef USE_NONBLOCK
+     if( (arg = fcntl(sock, F_GETFL, NULL)) < 0) {
+        perror("fcntl");
+        return NULL;
+     }
+     arg |= O_NONBLOCK;
+     if( fcntl(sock, F_SETFL, arg) < 0) {
+        perror("fcntl");
+        return NULL;
+     }
+ #endif
+
+     memset(&sin, '\0', sizeof(sin));
+     sin.sin_port = htons(port);
+     sin.sin_family = addrtype;
+     if (!inet_aton(addr, &sin.sin_addr)) {
+ 	perror("inet_aton");
+ 	return NULL;
+     }
+ #ifdef USE_NONBLOCK
+     if (connect(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0 &&
+                    errno != EINPROGRESS) {
+ #else
+     if (connect(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
+ #endif
+ 	perror("connect");
+ 	return NULL;
+     }
+     
+     conn=flist;
+     flist=(connection *)conn->chain.next;
+     conn->fd=sock;
+     conn->chain.name = (char *) NULL;
+     conn->udpbuf=(char *) NULL;
+     inaddr.in.addr = sin.sin_addr;
+     inaddr.ipv6 = FALSE;
+     conn->addr = ipa_new(&inaddr);
+     conn->at=sin.sin_port;
+     FD_SET(sock, &infds);
+     FD_SET(sock, &outfds);
+     FD_CLR(sock, &readfds);
+     FD_SET(sock, &writefds);
+     if (sock > maxfd) {
+ 	maxfd=sock;
+     }
+     return conn;
+ }
+ 
+ int conn_udpreceive(conn, buffer, size, host, port)
+ connection *conn;
+ char *buffer;
+ int size;
+ char **host;
+ int *port;
+ {
+     if (FD_ISSET(conn->fd, &readfds)) {
+ 	struct sockaddr_in from;
+ 	int fromlen, sz;
+ 
+ 	fromlen=sizeof(struct sockaddr_in);
+ 	sz=recvfrom(conn->fd, buffer, size, 0, (struct sockaddr *) &from,
+ 		    &fromlen);
+ 	if (sz<0) {
+ 	    perror("recvfrom");
+ 	    return sz;
+ 	}
+ 	*host=inet_ntoa(from.sin_addr);
+ 	*port=ntohs(from.sin_port);
+ 	return sz;
+     }
+     return -1;
+ }
+
+
+#ifdef USE_NONBLOCK
+ /*
+  * check for a connection in pending state and see if it is connected.
+  */
+ int conn_check_connected(conn)
+ connection * conn;
+ {
+     Uint t;
+     unsigned int mtime;
+     int retval;
+     int optval;
+     fd_set fdwrite;
+     socklen_t lon;
+     struct timeval timeout;
+
+     t = 0;
+     mtime = 0;
+
+     FD_ZERO(&fdwrite);
+     FD_SET(conn->fd,&fdwrite);
+
+     timeout.tv_sec = t;
+     timeout.tv_usec = mtime * 1000L;
+
+     retval = select(conn->fd + 1, NULL, &fdwrite, NULL, &timeout);
+
+     /*
+      * Delayed connect completed, check for errors
+      */
+     if(retval > 0) {
+         lon = sizeof(int);
+         /*
+          * Get error state for the socket
+          */
+         if (getsockopt(conn->fd, SOL_SOCKET, SO_ERROR, (void*)(&optval), &lon) < 0) {
+             return -1;
+         }
+         if (optval != 0) {
+             errno = optval;
+             return -1;
+         } else {
+             errno = 0;
+             return 1;
+         }
+     } else if(retval < 0) {
+         return -1;
+     }
+     return 0;
+ }
+
+ #endif
+ #endif
+ 
diff -ruN dgd/src/host.h dgd-net/src/host.h
--- dgd/src/host.h	2008-10-06 13:01:50.000000000 +0200
+++ dgd-net/src/host.h	2008-10-06 13:07:40.000000000 +0200
@@ -330,6 +330,7 @@
 # define VT	'\013'
 # define FF	'\014'
 # define CR	'\015'
+# define ESC	'\033'
 
 struct _struct_al_ { long l; short s; };
 # define STRUCT_AL	(sizeof(struct _struct_al_) - sizeof(long))
diff -ruN dgd/src/kfun/std.c dgd-net/src/kfun/std.c
--- dgd/src/kfun/std.c	2008-10-06 13:01:50.000000000 +0200
+++ dgd-net/src/kfun/std.c	2009-03-02 20:33:53.000000000 +0100
@@ -619,7 +619,11 @@
 
     if (f->sp->type == T_OBJECT) {
 	obj = OBJR(f->sp->oindex);
+#ifdef NETWORK_PACKAGE
+        if (comm_is_connection(obj)) {
+#else
 	if ((obj->flags & O_SPECIAL) == O_USER) {
+#endif
 	    PUT_STRVAL(f->sp, comm_ip_number(obj));
 	    return 0;
 	}
@@ -650,7 +654,11 @@
 
     if (f->sp->type == T_OBJECT) {
 	obj = OBJR(f->sp->oindex);
+#ifdef NETWORK_PACKAGE
+        if (comm_is_connection(obj)) {
+#else
 	if ((obj->flags & O_SPECIAL) == O_USER) {
+#endif
 	    PUT_STRVAL(f->sp, comm_ip_name(obj));
 	    return 0;
 	}
@@ -676,7 +684,11 @@
 int kf_users(f)
 register frame *f;
 {
+#ifdef NETWORK_PACKAGE
+    PUSH_ARRVAL(f, comm_users(f->data, FALSE));
+#else
     PUSH_ARRVAL(f, comm_users(f->data));
+#endif
     i_add_ticks(f, f->sp->u.array->size);
     return 0;
 }
@@ -967,7 +979,7 @@
 }
 # endif
 
-
+#ifndef NETWORK_PACKAGE
 # ifdef FUNCDEF
 FUNCDEF("send_datagram", kf_send_datagram, pt_send_datagram)
 # else
@@ -976,7 +988,7 @@
 
 /*
  * NAME:	kfun->send_datagram()
- * DESCRIPTION:	send a datagram to a user
+ * DESCRIPTION:	send a datagram to a user (non networkpackage function)
  */
 int kf_send_datagram(f)
 register frame *f;
@@ -1024,7 +1036,7 @@
     return 0;
 }
 # endif
-
+# endif
 
 # ifdef FUNCDEF
 FUNCDEF("block_input", kf_block_input, pt_block_input)
@@ -1235,6 +1247,214 @@
 }
 # endif
 
+#ifdef NETWORK_PACKAGE
+# ifdef FUNCDEF
+FUNCDEF("open_port", kf_open_port, pt_open_port)
+#else
+char pt_open_port[] = { C_TYPECHECKED | C_STATIC ,1 ,1 ,0 ,8,
+		   T_VOID, T_STRING, T_INT};
+    
+/* 
+ * NAME:        kfun->open_port
+ * DESCRIPTION: open a listening port
+ */
+int kf_open_port(f, nargs)
+register frame *f;
+int nargs;
+{
+    unsigned short port;
+    unsigned char protocol;
+    char *protoname;
+    object *obj;
+
+    if (f->lwobj != (array *) NULL) {
+	error("open_port() in non-persistent object");
+    }
+    obj = OBJW(f->oindex);
+    
+    if (obj->count == 0) {
+	error("open_port() in destructed object");
+    }
+    
+    if (obj->flags & O_SPECIAL) {
+	error("open_port() in special purpose object");
+    }
+
+    if (f->level != 0) {
+	error("open_port() within atomic function");
+    }
+
+    port=0;
+    if (nargs==2)
+    {
+       port=f->sp->u.number;
+       if ((port < 1)) /* || (port > 65535)) */ {
+         error("Port number not in allowed range");
+       }
+       f->sp++;
+    }
+    protoname=f->sp->u.string->text;
+    if (!strcmp(protoname,"tcp")) {
+	protocol=P_TCP;
+    } else if (!strcmp(protoname, "udp")) {
+	protocol=P_UDP;
+    } else if (!strcmp(protoname, "telnet")){
+	protocol=P_TELNET;
+    } else {
+	error("Unkown protocol");
+    }
+    str_del(f->sp->u.string);
+    comm_openport(f, obj, protocol, port);
+    *f->sp=nil_value;
+    return 0;
+}    
+#endif
+
+# ifdef FUNCDEF
+FUNCDEF("connect", kf_connect, pt_connect)
+#else
+char pt_connect[] = { C_TYPECHECKED | C_STATIC , 2, 1, 0, 9,
+		      T_VOID, T_STRING, T_INT, T_STRING };
+    
+/*
+ * NAME:        kfun->connect
+ * DESCRIPTION: connect to a server
+ */
+int kf_connect(f, nargs)
+register frame *f;
+int nargs;
+{
+    char * addr, proto, *protoname;
+    unsigned short port;
+    object *obj;
+
+    if (f->lwobj != (array *) NULL) {
+	error("connect() in non-persistent object");
+    }
+    obj = OBJW(f->oindex);
+    
+    if (obj->count == 0) {
+	error("connect() in destructed object");
+    }
+    
+    if (obj->flags & O_SPECIAL) {
+	error("connect() in special purpose object");
+    }
+
+    if (f->level != 0) {
+	error("connect() within atomic function");
+    }
+
+    if (nargs==3) {
+	protoname=f->sp->u.string->text;
+	if (!strcmp(protoname, "tcp")) {
+	    proto=P_TCP;
+	} else if (!strcmp(protoname, "telnet")) {
+	    proto=P_TELNET;
+	}
+	else
+	    return 3;
+	str_del((f->sp++)->u.string);
+    }
+
+    port=(f->sp++)->u.number;
+    if (port < 1) /* || port > 65535) */ {
+	error("Port number out of range");
+    }
+    addr=f->sp->u.string->text;
+
+    comm_connect(f, obj, addr, proto, port);
+    *f->sp=nil_value;
+    return 0;
+}    
+#endif
+
+# ifdef FUNCDEF
+FUNCDEF("ports", kf_ports, pt_ports)
+# else
+char pt_ports[] = { C_STATIC, 0,0,0,6,T_OBJECT | (1 << REFSHIFT)};
+
+/*
+ * NAME:	kfun->ports()
+ * DESCRIPTION:	return the array of port objects
+ */
+int kf_ports(f)
+register frame *f;
+{
+    PUSH_ARRVAL(f, comm_users(f->data, TRUE));
+    i_add_ticks(f, f->sp->u.array->size);
+    return 0;
+}
+# endif
+
+# ifdef FUNCDEF
+FUNCDEF("close_user", kf_close_user, pt_close_user)
+# else 
+char pt_close_user[] = { C_STATIC,0,0,0,6, T_VOID};
+/*
+ * NAME:	kfun->close_user()
+ * DESCRIPTION:	return the array of port objects
+ */
+int kf_close_user(f)
+register frame *f;
+{
+    register object *obj;
+
+    if (f->lwobj != (array *) NULL) {
+	error("close_user() in non-persistent object");
+    }
+
+    obj = OBJW(f->oindex);
+    
+    if (!((obj->flags & O_SPECIAL) == O_USER)) {
+	error("close_user() for non user-object");
+    }
+    
+    if (f->level != 0) {
+	error("close_user() in atomic function");
+    }
+    
+    comm_close(f, obj);
+    *--f->sp = nil_value;
+    return 0;
+}
+# endif
+
+# ifdef FUNCDEF
+FUNCDEF("send_datagram", kf_send_datagram, pt_send_datagram)
+# else 
+char pt_send_datagram[] = { C_TYPECHECKED | C_STATIC, 3,0,0,9,T_INT, 
+			     T_STRING, T_STRING, T_INT};
+/*
+ * NAME:	kfun->send_datagram()
+ * DESCRIPTION:	send a udp datagram (Network Package Function)
+ */
+int kf_send_datagram(f)
+register frame *f;
+{
+    register object *obj;
+    int num;
+    string *str,*ip;
+    int port;
+    
+    num=0;
+    obj=OBJW(f->oindex);
+    port=(f->sp++)->u.number;
+    ip=(f->sp++)->u.string;
+    str=f->sp->u.string;
+    if (f->lwobj == (array *) NULL) {
+	if ((obj->flags & O_SPECIAL) == O_USER && obj->count != 0) {
+	    num = comm_senddatagram(obj, str, ip, port);
+	}
+    }
+    str_del(ip);
+    str_del(f->sp->u.string);
+    PUT_INTVAL(f->sp, num);
+    return 0;
+}
+# endif
+#endif
+
 
 # ifdef FUNCDEF
 FUNCDEF("shutdown", kf_shutdown, pt_shutdown)
diff -ruN dgd/src/lex/ppcontrol.c dgd-net/src/lex/ppcontrol.c
--- dgd/src/lex/ppcontrol.c	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/src/lex/ppcontrol.c	2008-05-19 16:14:50.000000000 +0200
@@ -60,6 +60,9 @@
     mc_init();
     special_define();
     mc_define("__DGD__", "\0111\011", -1);	/* HT 1 HT */
+#ifdef NETWORK_PACKAGE
+    mc_define("__NETWORK_PACKAGE__", (char *) NULL, -1);
+#endif 
     pps_init();
     include_level = level;
     ifs = &top;
diff -ruN dgd/src/Makefile dgd-net/src/Makefile
--- dgd/src/Makefile	2008-05-19 14:59:44.000000000 +0200
+++ dgd-net/src/Makefile	2008-05-19 16:14:50.000000000 +0200
@@ -2,7 +2,7 @@
 # Makefile for DGD, Dworkin's Generic Driver
 #
 HOST=	DARWIN
-DEFINES=-D$(HOST) #-DDUMP_FUNCS
+DEFINES=-D$(HOST) -DNETWORK_PACKAGE -DINET6=0 -DUSE_NONBLOCK #-DDUMP_FUNCS
 DEBUG=	-g -DDEBUG
 CCFLAGS=$(DEFINES) $(DEBUG)
 CFLAGS=	-I. -Icomp -Ilex -Ied -Iparser -Ikfun $(CCFLAGS)
diff -ruN dgd/src/version.h dgd-net/src/version.h
--- dgd/src/version.h	2008-12-13 18:49:02.000000000 +0100
+++ dgd-net/src/version.h	2009-02-13 23:32:17.000000000 +0100
@@ -1 +1 @@
-# define VERSION	"DGD 1.2.157"
+# define VERSION	"DGD 1.2.157-NET-04"
